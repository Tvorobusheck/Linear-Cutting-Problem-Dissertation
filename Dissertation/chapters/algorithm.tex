\chapter{Решение задачи}\label{ch:algorithm}
\section{Алгоритм}
Задачи раскроя и планирования производства традиционно рассматриваются в рамках методов линейного и целочисленного программирования, что отражено в классических и обзорных работах по задаче раскроя и её модификациям~\cite{haessler1991, martina2022}. Вместе с тем применение точных методов в расширенных практических постановках сопряжено с существенными ограничениями.

Это обусловлено наличием большого числа дискретных, логических и технологических ограничений, связанных с использованием нескольких типов оборудования, необходимостью учёта переналадок, а также дополнительных характеристик заказов. Как показано в ряде исследований, включение таких условий в линейные модели приводит к значительному росту размерности задачи и числа бинарных переменных~\cite{sgp_ccp2021_cutting_stock_modes, mobasher2013, vanderbeck2000}.

Кроме того, рассматриваемая задача объединяет элементы раскроя, календарного планирования и распределения ресурсов во времени, что существенно затрудняет формализацию производственного расписания в рамках классических оптимизационных моделей~\cite{gao_energy_2019, keskinocak2002}. В связи с этим в работе применяется генетический алгоритм, позволяющий учитывать сложную структуру ограничений и получать допустимые решения за приемлемое вычислительное время, что подтверждается результатами современных исследований~\cite{klimenko2024_prin, genetics_2, klimenko2025ivdon}.


Генетические и эволюционные алгоритмы являются методами поиска и оптимизации, которые могут существенно улучшить решение задачи раскроя с минимизацией перестановок ножей. Одним из фундаментальных преимуществ этих алгоритмов является возможность гибко управлять временем выполнения, что позволяет адаптировать их под конкретные требования задачи. При этом каждая итерация не ухудшает качество текущего решения, что делает процесс менее уязвимым к локальным минимумам \cite{genetics_2, genetics_1}. Эффективность применения генетических и эволюционных алгоритмов тесно связана с мощностью вычислительных ресурсов, что часто подразумевает использование высокопроизводительных вычислительных систем, таких как суперкомпьютеры и кластеры \cite{evolution_1, evolution_2}.


В предыдущих работах предлагался алгоритм случайного поиска с элементами генетического алгоритма, называемый генетический поиск (GS) \cite{klimenko2024_prin, klimenko2025ivdon, klimenko2025fruct}. Однако он мог работать с учетом меньшей части условий задачи. Данный алгоритм расширен для работы с учетом ограничений по срокам заказов, плотности рулонов, марок бумаги, кромки тамбуров, складов, слоев и БРС.

Данный алгоритм итеративно формирует новые популяции
\[
S = \{ S_1, S_2, \ldots, S_C \},
\]
где:
\begin{itemize}
    \item $S_t$ — популяция на итерации $t$, состоящая из глобальных планов раскроя $G = (\overline{\overline{X}},\overline{\overline{Y}},\overline{\overline{Z}})$;
    \item $S_{t,i}$ — $i$-й глобальный план раскроя $G \in S_t$;
    \item начальная популяция $S_0$ состоит из случайных глобальных планов $G$, удовлетворяющих ограничениям на ширину и выполнение заказов.
\end{itemize}

Размер начальной популяции определяет количество итераций, а значит, влияет на точность и скорость работы алгоритма \ref{alg:genetic_search}.

Каждая итерация включает два этапа:
\begin{enumerate}
    \item \textbf{Мутация (GlobalMutate)} (алгоритм \ref{alg:mutate} и \ref{alg:global_mutate}) — создаются новые планы $G'$. Если новый план лучше старого $\mu(G') < \mu(G)$, то старый план заменяется.
    \item \textbf{Кроссинговер (Crossingover)} (алгоритм \ref{alg:crossingover}) — для пары соседних глобальных планов $S_{t,2i-1}$ и $S_{t,2i}$ выбирается наименьший план по $\mu(G)$. В результате размер популяции уменьшается вдвое.
\end{enumerate}

В конце работы алгоритма остаётся один глобальный план $G'$, который не хуже любого из исходных $G \in S_0$. Чем больше размер начальной популяции, тем выше вероятность получить $G'$ с минимальными отходами и числом перестановок ножей.

\subsection{Описание алгоритма Mutate}
Алгоритм получает на вход один план нарезки $Y$, состоящий из наборов раскроев $Y_{i,j}$ и форматов $y_{i,j,k}$, где ${r^Y}_{i,j,k}$~--- ширина формата, а ${{g^Y}}_{i,j,k}$~--- номер заказа. 

\begin{enumerate}
  \item Копируется исходный план $Y$ в новый $newY$, чтобы не изменять исходный объект.
  \item Для каждого раскроя $newY_{i,j}$ случайным образом перемешивается порядок форматов $y_{i,j,k}$.
  \item Случайным образом перемешивается порядок самих раскроев $newY_{i,j}$.
  \item Возвращается изменённый план $newY$.
\end{enumerate}

Таким образом, $\textbf{Mutate}(Y)$ создаёт вариацию исходного плана раскроя для поиска новых комбинаций.

\begin{ListingEnv}[!h]
    \captiondelim{ }
    \caption{Мутация отдельного плана нарезки}\label{alg:mutate}
    \begin{lstlisting}
Mutate(Y):
    newY = Y
    for each newY_{i,j} in newY do
        # Перемешать форматы y_{i,j,k} внутри раскроя
        shuffle(newY_{i,j})
    # Перемешать порядок раскроев
    shuffle(newY)
    return newY
    \end{lstlisting}
\end{ListingEnv}

\subsection{Описание алгоритма GlobalMutate}
На вход подаётся глобальный план $G = (\overline{\overline{X}}, \overline{\overline{Y}}, \overline{\overline{Z}})$.

\begin{enumerate}
  \item Копируется $G$ в новый план $newG$.
  \item Для каждого плана нарезки $Y \in \overline{\overline{Y}}$ вызывается $\textbf{Mutate}(Y)$.
  \item Пересоздаётся план производства $\overline{\overline{X}}$ функцией $\textbf{GenerateProductionPlan}(newG)$ в соответствии со всеми ограничениями.
  \item Пересоздаётся очередь событий $\overline{\overline{Z}}$ функцией $\textbf{GenerateEventQueue}(newG)$ в соответствии со всеми ограничениями.
  \item Если $\mu(newG) < \mu(G)$, то выбирается $newG$.
  \item В противном случае возвращается исходный $G$.
\end{enumerate}

В шагах 5-6 алгоритм $\textbf{GlobalMutate}(G)$ обеспечивает, что решение будет не хуже исходного $G$ по целевой функции  $(\mu)$.

\begin{ListingEnv}[!h]
    \captiondelim{ }
    \caption{Мутация глобального плана}\label{alg:global_mutate}
    \begin{lstlisting}
GlobalMutate(G):
    newG = G
    for each Y in newG do
        newY = Mutate(Y)
    # Пересоздание плана производства в соответствии с новым планом нарезки
    GenerateProductionPlan(newG)
    # Пересоздание очереди событий в соответствии с новыми планами
    GenerateEventQueue(newG)
    if mu(newG) < mu(G) then
        return newG
    else
        return G
    \end{lstlisting}
\end{ListingEnv}

\subsection{Описание алгоритма Crossingover}
На вход подаются два глобальных плана $G^1$ и $G^2$. Сравниваются значения целевых функций для обоих планов $\mu(G^1)$ и $\mu(G^2)$. Таким образом, $\textbf{Crossingover}$ оставляет более эффективное решение.

\begin{ListingEnv}[!h]
    \captiondelim{ }
    \caption{Кроссинговер двух глобальных планов}\label{alg:crossingover}
    \begin{lstlisting}
Crossingover(G1, G2):
    if mu(G1) < mu(G2) then
        return G1
    else
        return G2
    \end{lstlisting}
\end{ListingEnv}

\subsection{Описание алгоритма GeneticSearch}
Основной алгоритм оптимизации, который итеративно улучшает популяцию глобальных планов $S_t$.

\begin{enumerate}
  \item На вход подаётся начальная популяция $S_0$ допустимых глобальных планов $G$. Размер $|S_0|$ влияет на баланс между скоростью и качеством поиска.
  \item Пока $|S_t| > 1$:
  \begin{enumerate}
    \item Для каждого $S_{t,i}$ вызывается $\textbf{GlobalMutate}(S_{t,i})$.
    \item Для каждой пары $(S_{t,2i-1}, S_{t,2i})$ выполняется $\textbf{Crossingover}$, и лучший план переходит в $S_{t+1}$.
    \item Если $|S_t|$ нечётное, последний план $S_{t,\lceil n/2 \rceil}$ копируется в $S_{t+1}$.
    \item Увеличивается индекс итерации $t \leftarrow t+1$.
  \end{enumerate}
  \item Когда $|S_t| = 1$, итоговый план $S_{t,1}$ возвращается как решение $G'$.
\end{enumerate}

Алгоритм $\textbf{GeneticSearch}$ сочетает случайные мутации и эволюционную селекцию, постепенно улучшая глобальный план раскроя. Так как $\textbf{Crossingover}$ передает в следующую популяцию наилучшее из решений, а $\textbf{GlobalMutate}$ не ухудшает исходный план, то $\textbf{GeneticSearch}$ гарантирует, что выдаст решение не хуже чем в начальной популяции $S_0$.

\begin{ListingEnv}[!h]
    \captiondelim{ }
    \caption{Генетический поиск}\label{alg:genetic_search}
    \begin{lstlisting}
GeneticSearch(S0):
    t = 0
    while |S_t| > 1 do
        n = |S_t|
        for i = 1 to n do
            S_{t,i} = GlobalMutate(S_{t,i})
        for i = 1 to floor(n/2) do
            S_{t+1,i} = Crossingover(S_{t,2i-1}, S_{t,2i})
        if n mod 2 == 1 then
            S_{t+1,ceil(n/2)} = S_{t,n}
        t = t + 1
    return S_{t,1}
    \end{lstlisting}
\end{ListingEnv}

\subsection{Сложность алгоритма}

Для алгоритма \ref{alg:genetic_search} размер популяции уменьшается вдвое на каждой итерации из-за того, что $\textbf{Crossingover}$ выбирает только один из двух планов и перадет его в следующую популяцию. Поэтому выполняется
\[
O(|S_0|\log(|S_0|))
\]
итераций. Каждая итерация включает обработку планов нарезки в алгоритме \ref{alg:mutate}. Так как план нарезки состоит из
\[
\sum_{i=1}^{Q} q_i
\]
форматов (все заказы должны быть выполнены). Итоговая алгоритмическая сложность указана в уравнении~\ref{eq:genetic_search_complexity} без учета \textbf{GenerateProductionPlan} и \textbf{GenerateEventQueue} из алгоритма \ref{alg:global_mutate}:
\begin{equation}
    O\left(|S_0| \log(|S_0|)\sum_{i=1}^{Q} q_i \right).
    \label{eq:genetic_search_complexity}
\end{equation}

%--------------------------------------------------------
\section{Результаты}
Рассмотрим пример и результаты работы программной реализации. 
\subsection{Условия примера}

В примере есть две марки бумаги C0000001 и B0000002. Их скорости установки $B=\{0:00:00, 1:00:00\}$. Заданы заказы, представленные в таблице~\ref{tab:orders}.

\begin{table}[h]
\centering
\caption{Множество заказов $O$}
\label{tab:orders}
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline
Заказ $i$ & $w_{i}$ & $f_{i}$ & $p_{i}$ & $l_{i}$ & $h_{i}$ & $g_{i}$ \\
\hline
${1}$ & $5$  & $1$ (C0000001) & $100$ & $2$ & 12.12.2024 8:00 & $1$ \\
${2}$ & $20$ & $2$ (B0000002) & $125$ & $2$ & 12.12.2024 8:00 & $0$ \\
${3}$ & $30$ & $1$ (C0000001) & $100$ & $1$ & 12.12.2024 8:00 & $0$ \\
${4}$ & $40$ & $1$ (C0000001) & $100$ & $1$ & 12.12.2024 8:00 & $0$ \\
${5}$ & $50$ & $2$ (B0000002) & $125$ & $1$ & 12.12.2024 8:00 & $0$ \\
\hline
\end{tabular}
\end{table}

Время начала производства $H=11.12.2024\ 8:00$. Размер кромки тамбура $V=1$.
Далее рассмотрим множество бумагоделательных машин $M = \{m_{1}, m_{2}\}$. Заданные машины приведены в таблице~\ref{tab:machines}.

\begin{table}[h]
\centering
\caption{Множество бумагоделательных машин $M$}
\label{tab:machines}
\begin{tabular}{|c|c|c|c|c|}
\hline
Машина $i$ & ${w^m}_{i}$ & ${v^m}_{i}$ & ${g^m}_{i}$ \\
\hline
1 & $40$ & 0:06:00 & 0:01:00 \\
2 & $60$ & 0:06:00 & 0:02:00 \\
\hline
\end{tabular}
\end{table}

Параметры ПРС приведены в таблице~\ref{tab:cutters}.

\begin{table}[h]
\centering
\caption{Множество продольно-резательных станков $C$}
\label{tab:cutters}
\begin{tabular}{|c|c|c|c|c|c|c|}
\hline
Станок $i$ & ${w^c}_{i}$ & ${n^c}_{i}$ & ${v^c}_{i}$ & ${k^c}_{i}$ & ${g^c}_{i}$ \\
\hline
$1$ & $60$ & $3$ & 1:30:00 & 48:00 & 0 \\
$2$ & $40$ & $2$ & 1:12:00 & 36:00 & 0 \\
$3$ & $20$ & $3$ & 1:12:00 & 36:00 & 1 \\
\hline
\end{tabular}
\end{table}

Кроме того, заданы склады $T = \{t_{1}, t_{2}\}$, каждый склад $t_{k}$ характеризуется максимальной шириной ${r^T}_{k}$ и вместимостью ${u^T}_{k}$ (таблица~\ref{tab:storages}).

\begin{table}[h]
\centering
\caption{Множество складов $T$}
\label{tab:storages}
\begin{tabular}{|c|c|c|}
\hline
Склад $i$ & ${r^T}_{i}$ & ${u^T}_{i}$ \\
\hline
1 & 40 & 8 \\
2 & 60 & 4 \\
\hline
\end{tabular}
\end{table}

\subsection{Решение примера}

Общий план производства бумаги представлен в таблице~\ref{tab:production_plan}.


\begin{table}[htbp]
\centering
\caption{План производства бумаги $\overline{\overline{X}}$}
\label{tab:production_plan}
\begin{tabular}{|c|ccc|ccc|}
\hline
Шаг производства $i$
  & \multicolumn{3}{c|}{$\overline{\overline{X_{1}}}$ (БДМ $m_{1}$)} 
  & \multicolumn{3}{c|}{$\overline{\overline{X_{2}}}$ (БДМ $m_{2}$)} \\
\cline{2-7}
  & ${w^X}_{1,i}$ & ${f^X}_{1,i}$ & ${p^X}_{1,i}$ 
  & ${w^X}_{2,i}$ & ${f^X}_{2,i}$ & ${p^X}_{2,i}$ \\
\hline
1 & 40 & 1 & 100 & 60 & 1 & 100 \\
2 & 40 & 1 & 100 & 60 & 1 & 100 \\
3 & 40 & 2 & 125 & 60 & 2 & 125 \\
4 & 40 & 2 & 125 & 60 & 2 & 125 \\
5 &  &  &  & 60 & 2 & 125 \\
\hline
\end{tabular}
\end{table}

Общий план нарезки бумаги представлен в таблице~\ref{tab:cutting_plan_all}. Из-за кромки тамбура $V=1$ нельзя заполнить полностью ширину ПРС в раскрое $y_{i, j, k}$. ${g^Y}_{i,j,k}=0$ обозначает, что рулон идет на БРС $c_3$.

\begin{table}[htbp]
\centering
\caption{План нарезки бумаги $\overline{\overline{Y}}$ по ПРС $c_{i}$}
\label{tab:cutting_plan_all}
\begin{tabular}{|c|c|c|c|c|c|}
\hline
$i$ & $j$ & Форматы $y_{i,j,k}=({r^Y}_{i,j,k},{g^Y}_{i,j,k})$ & ${f^Y}_{i,j}$ & ${p^Y}_{i,j}$ & ${l^Y}_{i,j}$ \\
\hline
1 & 1 & $(40,4)$ & 1 & 100 & 1 \\
1 & 2 & $(40,4),\ (20,0)$ & 1 & 100 & 1 \\
1 & 3 & $(50,5)$ & 2 & 125 & 1 \\
1 & 4 & $(20,2),\ (20,2)$ & 2 & 125 & 2 \\
\hline
2 & 1 & $(30,3)$ & 1 & 100 & 1 \\
2 & 2 & $(20,0)$ & 1 & 100 & 1 \\
2 & 3 & $(20,2)$ & 2 & 125 & 2 \\
\hline
3 & 1 & $(5,1),\ (5,1)$ & 1 & 100 & 2 \\
\hline
\end{tabular}
\end{table}

Очередь событий представлена в таблице~\ref{tab:event_queue}. Она описывает пошаговое выполнение плана выпуска тамбуров и их последующую нарезку на ПРС.

\begin{table}[htbp]
\centering
\renewcommand{\arraystretch}{1.1}
\setlength{\tabcolsep}{3pt}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
\hline
№ & $h$ & $\overline{h}$ & $e$ & $d$ & $z$ & $\overline{t}_1$ & $\overline{t}_2$ & $\overline{t'}$ \\
\hline
1 & 08:00 & 08:06 & 0 & 1 & 1 & $\varnothing$ & $\varnothing$ & $\varnothing$ \\
2 & 08:00 & 08:06 & 0 & 2 & 1 & $\varnothing$ & $\varnothing$ & $\varnothing$ \\
3 & 08:06 & 08:12 & 0 & 2 & 2 & $X_{1,1}$ & $X_{2,1}$ & $\varnothing$ \\
4 & 08:06 & 08:12 & 0 & 1 & 2 & $X_{1,1}$ & $X_{2,1}$ & $\varnothing$ \\
5 & 08:06 & 09:54 & 1 & 2 & 1 & $\varnothing$ & $X_{2,1}$ & $X_{1,1}$ \\
6 & 08:06 & 10:24 & 1 & 1 & 1 & $\varnothing$ & $\varnothing$ & $X_{2,1}$ \\
7 & 08:12 & 09:43 & 0 & 1 & 3 & $X_{1,2}$ & $X_{2,2}$ & $\varnothing$ \\
8 & 08:12 & 10:08 & 0 & 2 & 3 & $X_{1,2}$ & $X_{2,2}$ & $\varnothing$ \\
9 & 09:43 & 09:49 & 0 & 1 & 4 & $\{X_{1,2}, X_{1, 3}\}$ & $X_{2,2}$ & $\varnothing$ \\
10 & 09:54 & 11:42 & 1 & 2 & 2 & $\{X_{1,3}, X_{1,4}\}$ & $X_{2,2}$ & $X_{1,2}$ \\
11 & 10:08 & 10:14 & 0 & 2 & 4 & $\{X_{1,3}, X_{1,4}\}$ & $\{X_{2,2},X_{2,3}\}$ & $\varnothing$ \\
12 & 10:14 & 10:20 & 0 & 2 & 5 & $\{X_{1,3}, X_{1,4}\}$ & $\{X_{2,2},X_{2,3},X_{2,4}\}$ & $\varnothing$ \\
13 & 10:24 & 12:42 & 1 & 1 & 2 & $\{X_{1,3}, X_{1,4}\}$ & $\{X_{2,3},X_{2,4}\}$ &  $X_{2,2}$ \\
14 & 11:42 & 14:42 & 1 & 2 & 3 & $y_{2,2,1}$ & $\{X_{2,3},X_{2,4},X_{2,5}\}$ & $\{X_{1,3},X_{1,4}\}$ \\
15 & 12:42 & 16:18 & 1 & 3 & 1 & $\varnothing$ & $\{X_{2,3},X_{2,4},X_{2,5}\}$ & $\{y_{1,2,2},y_{2,2,1}\}$ \\
16 & 12:42 & 15:00 & 1 & 1 & 3 & $\varnothing$ & $\{X_{2,4},X_{2,5}\}$ & $X_{2,3}$ \\
17 & 15:00 & 19:36 & 1 & 1 & 4 & $\varnothing$ & $\varnothing$ & $\{X_{2,4},X_{2,5}\}$ \\
\hline
\end{tabular}
\caption{Очередь событий $\overline{\overline{Z}}$}
\label{tab:event_queue}
\end{table}


По результатам моделирования были получены следующие значения целевой функции:
\[
\mu(G) = \langle \omega(G),\varphi(G),\tau(\overline{\overline{Y}}) \rangle = \langle 104,\ 4,\ 10 \rangle,
\]
где $\omega(G)=104$ -- суммарная ширина отходов, $\varphi(G)=4$ -- максимальное количество раскроев на ПРС, $\tau(\overline{\overline{Y}})=10$ -- количество перестановок ножей.

Время работы программы составило 0,2 секунды для популяции размером 10.

\subsection{Сравнение популяций}

Для оценки влияния размера популяции на результаты алгоритма были проведены серии запусков с популяциями 5, $10$, 20, $100$, $1000$ и $10000$.  
В качестве метрик использовались:  
- $\omega(G)$ — суммарная ширина отходов;  
- $\varphi(G)$ — максимальное количество раскроев на одном ПРС;  
- $\tau(\overline{\overline{Y}})$ — количество перестановок ножей;  
- Время работы программы (секунды), включая время на генерацию популяций.  

Результаты представлены в таблице~\ref{tab:populations}.

\begin{table}[h]
\centering
\caption{Сравнение результатов при разных размерах популяции}
\label{tab:populations}
\begin{tabular}{|c|c|c|c|c|}
\hline
Размер популяции & $\omega(G)$ & $\varphi(G)$ & $\tau(\overline{\overline{Y}})$ & Время работы, сек \\
\hline
$5$    & $124$ & $5$ & $10$ & $0.04$ \\
$10$    & $104$ & $4$ & $10$ & $0.2$ \\
$20$    & $104$ & $4$ & $8$ & $0.2$ \\
$100$   & $65$  & $4$ & $9$  & $0.7$ \\
$1000$  & $65$  & $4$ & $9$  & $20.4$ \\
$10000$ & $65$  & $4$ & $9$  & $81.8$ \\
\hline
\end{tabular}
\end{table}


График на рисунке~\ref{fig:populations} иллюстрирует зависимость между размером популяции, качеством решений и временем работы.


\begin{figure}[h!]
% --- 1. Отходы
\begin{tikzpicture}
\begin{axis}[
    width=0.45\textwidth,
    height=0.35\textwidth,
    xlabel={Размер популяции},
    ylabel={$\omega(G)$},
    xmin=0, xmax=10000,
    ymin=0, ymax=150,
    xmode=log,
    log basis x=10,
    grid=both,
    xtick={10,100,1000,10000},
    xticklabels={10,100,1000,10000}
]
\addplot[
    mark=*,
    orange,
    thick
] coordinates {
    (5, 124) (10,104) (20, 104) (100,65) (1000,65) (10000,65)
};
\end{axis}
\end{tikzpicture}
\hfill
% --- 2. Раскрои
\begin{tikzpicture}
\begin{axis}[
    width=0.45\textwidth,
    height=0.35\textwidth,
    xlabel={Размер популяции},
    ylabel={$\varphi(G)$},
    xmin=0, xmax=10000,
    ymin=0, ymax=7,
    xmode=log,
    log basis x=10,
    grid=both,
    xtick={10,100,1000,10000},
    xticklabels={10,100,1000,10000}
]
\addplot[
    mark=square*,
    blue,
    thick
] coordinates {
    (5, 5) (10,4) (20, 4) (100,4) (1000,4) (10000,4)
};
\end{axis}
\end{tikzpicture}

\vspace{0.5cm}

% --- 3. Перестановки
\begin{tikzpicture}
\begin{axis}[
    width=0.45\textwidth,
    height=0.35\textwidth,
    xlabel={Размер популяции},
    ylabel={$\tau(\overline{\overline{Y}})$},
    xmin=0, xmax=10000,
    ymin=0, ymax=11,
    xmode=log,
    log basis x=10,
    grid=both,
    xtick={10,100,1000,10000},
    xticklabels={10,100,1000,10000}
]
\addplot[
    mark=triangle*,
    green!60!black,
    thick
] coordinates {
    (5, 10) (10,10) (20, 8) (100,9) (1000,9) (10000,9)
};
\end{axis}
\end{tikzpicture}
\hfill
% --- 4. Время
\begin{tikzpicture}
\begin{axis}[
    width=0.45\textwidth,
    height=0.35\textwidth,
    xlabel={Размер популяции},
    ylabel={$t$, сек},
    xmin=0, xmax=10000,
    ymin=0, ymax=100,
    xmode=log,
    log basis x=10,
    grid=both,
    xtick={10,100,1000,10000},
    xticklabels={10,100,1000,10000}
]
\addplot[
    mark=o,
    red,
    thick
] coordinates {
    (5, 0.04) (10,0.2) (20, 0.2) (100,0.7) (1000,20.4) (10000,81.8)
};
\end{axis}
\end{tikzpicture}

\caption{Сравнение популяций по метрикам: (a) отходы $\omega(G)$, (b) раскрои $\varphi(G)$, (c) перестановки ножей $\tau(\overline{\overline{Y}})$, (d) время работы программы}
\label{fig:populations}
\end{figure}
\newpage

Из таблицы~\ref{tab:populations} и рисунка~\ref{fig:populations} видно, что увеличение размера популяции приводит к снижению отходов, количества раскроев и количества перестановок ножей, однако сопровождается  ростом времени вычислений.



%------------------------------------------------------------------------------
\subsection{Генерация очереди событий\protect\footnote{Класс \texttt{GlobalPlanEventQueueBuilder} реализует построение расписания на основе планов производства и раскроя.}}

В глобальном плане $G = (\overline{\overline{X}},\overline{\overline{Y}},\overline{\overline{Z}})$ необходимо построить календарь событий $\overline{\overline{Z}}$, отражающий последовательность выпуска тамбуров на БДМ и раскроя на ПРС/БРС.  Каждый элемент очереди $\overline{Z} = (h,\overline{h},e,d,z,\overline{T},\overline{\overline{T}},\overline{t}')$ фиксирует момент начала $h$ и окончания $\overline{h}$ работы на машине $d$, тип события $e\in\{0,1\}$ (0~— производство на БДМ, 1~— раскрой на ПРС/БРС), индекс плана $z$, а также снимки состояния складов до и после события.  В настоящем разделе приводится математическое описание алгоритма генерации расписания на базе класса \texttt{GlobalPlanEventQueueBuilder}.

\paragraph{Инициализация.} Пусть $H$ — момент запуска производства.  Для каждого продольно‑резательного станка $c\in C$ (ПРС/БРС) с планом раскроя $\overline{Y}_c=(Y_{c,1},\dots,Y_{c,q_c})$ определим счётчик $z_c=0$ — количество уже выполненных раскроев.  Для каждого бумагоделательного станка $m\in M$ с планом выпуска $\overline{X}_m=(X_{m,1},\dots,X_{m,p_m})$ определим счётчик $x_m=0$ — количество произведённых тамбуров.  Введём две структуры хранения:

\begin{itemize}
  \item \emph{Текущее состояние склада} $\overline{T}$ — набор тамбуров и рулонов, доступных для последующей нарезки.  Изначально $\overline{T}$ пуст.
  \item \emph{Будущее состояние склада} $\overline{\overline{T}}$ — набор тамбуров, которые находятся в процессе производства на БДМ и будут переданы в $\overline{T}$ после завершения соответствующих событий.  Изначально $\overline{\overline{T}}$ пуст.
\end{itemize}

Текущее время обозначим через $t:=H$.  Также инициализируем две вспомогательные очереди: $\mathcal{E}$ — очередь событий с приоритетом по времени окончания (min‑heap) и $\mathcal{H}$ — история завершённых событий (будущая $\overline{\overline{Z}}$).

\paragraph{Доступные станки.} На каждом шаге алгоритма определяются множества доступных машин:
\begin{align*}
  C_{\mathrm{avail}}(t) &= \Bigl\{c\in C : z_c < |\overline{Y}_c|,\ \lambda_c \le t,\ \text{$\overline{T}$ содержит все тамбуры для раскроя $Y_{c,z_c+1}$}\Bigr\},\\
  M_{\mathrm{avail}}(t) &= \Bigl\{m\in M : x_m < |\overline{X}_m|,\ \lambda'_m \le t,\ \text{$\overline{\overline{T}}$ может вместить тамбур $X_{m,x_m+1}$}\Bigr\},
\end{align*}
где $\lambda_c$ (соответственно $\lambda'_m$) — время окончания последней операции на станке $c$ (соответственно $m$);  функция «может вместить» проверяет, что склад имеет свободную ширину и вместимость для будущего тамбура.  Если флаг $\textit{pms\_available}=\textit{False}$, то производство на БДМ запрещено, и $M_{\mathrm{avail}}(t)$ считается пустым.

\paragraph{Определение возможных событий.} Построим множество возможных типов операций в момент времени $t$:
\begin{equation*}
  E(t) = \begin{cases}
    \{0,1\}, & \text{если } M_{\mathrm{avail}}(t)\neq\varnothing \text{ и } C_{\mathrm{avail}}(t)\neq\varnothing;\\
    \{0\}, & \text{если } M_{\mathrm{avail}}(t)\neq\varnothing \text{ и } C_{\mathrm{avail}}(t)=\varnothing;\\
    \{1\}, & \text{если } M_{\mathrm{avail}}(t)=\varnothing \text{ и } C_{\mathrm{avail}}(t)\neq\varnothing;\\
    \varnothing, & \text{если } M_{\mathrm{avail}}(t)=\varnothing \text{ и } C_{\mathrm{avail}}(t)=\varnothing.
  \end{cases}
\end{equation*}
Если $E(t)\neq\varnothing$, то можно запланировать новое событие; в противном случае придётся дождаться завершения уже запущенных операций.

\paragraph{Обработка событий.} Алгоритм итеративно генерирует очередь событий следующим образом.

\begin{ListingEnv}[!h]
    \captiondelim{ }
    \caption{Генерация очереди событий \texttt{GenerateEventQueue}($G$)}\label{alg:generate_event_queue}
    \begin{lstlisting}
GenerateEventQueue(G):
    # Инициализация
    t = H  # текущее время
    init z_c = 0, lambda_c = H  for all c in C
    init x_m = 0, lambda'_m = H for all m in M
    T = ∅; T_future = ∅
    E = ∅; Hhist = ∅

    # Основной цикл
    while (∃ c: z_c < |Y_c|) or (∃ m: x_m < |X_m|) or (E ≠ ∅) do
        # Определение доступных машин и типов операций
        C_avail(t), M_avail(t) = define_by_formulas_above()
        Etypes = E(t)
        if Etypes ≠ ∅ then
            # Планируем новую операцию
            e = choose(Etypes)  # приоритет или случайный выбор
            if e == 1 then  # раскрой на ПРС/БРС
                c = choose(C_avail(t))
                R = required_reels_for(Y_{c, z_c+1})
                remove R from T and T_future
                τ = v^c_c * l^Y_{c, z_c+1} + k^c_c * (σ(c, z_c+1) - σ(c, z_c))
                Z = (t, t + τ, 1, c, z_c, T, T_future, ∅)
                push Z into E with key (t + τ)
                lambda_c = t + τ
                z_c = z_c + 1
            else  # e == 0, производство на БДМ
                m = choose(M_avail(t))
                τ = v^m_m + g^m_m * (p^X_{m, x_m+1} - p^X_{m, x_m}) + b_f
                Z = (t, t + τ, 0, m, x_m, T, T_future, ∅)
                push Z into E
                lambda'_m = t + τ
                x_m = x_m + 1
                place X_{m, x_m} into T_future
        else
            # Ожидание ближайшего завершения
            Z = pop_min_end_time(E)
            t = \overline{h}(Z)
            append Z to Hhist
            if e(Z) == 0 then  # завершилось производство
                move corresponding tambour from T_future to T
            else  # e(Z) == 1, завершился раскрой
                add produced rolls (from R) to T and T_future

    return Hhist  # упорядоченная очередь событий
    \end{lstlisting}
\end{ListingEnv}

\paragraph{Комментарии к алгоритму.}  
\begin{itemize}
  \item Величины $\lambda_c$ и $\lambda'_m$ фиксируют момент завершения последней операции на соответствующей машине; условие $t\ge \lambda_c$ (или $t\ge \lambda'_m$) гарантирует, что станок свободен в момент $t$.
  \item Функция $\sigma(c,z)$ обозначает суммарное количество перестановок ножей для $c$‑ой ПРС к моменту $z$‑го раскроя (см. формулу \eqref{eq:sigma} в разделе \ref{sec:constraints}); она используется при вычислении продолжительности раскроя.
  \item Условие «$\overline{T}$ содержит все тамбуры для раскроя $Y_{c,z_c+1}$» означает, что на складе имеются мастер‑рулоны нужной марки, плотности и ширины для выполнения очередного раскроя; функция \texttt{has\_supply} из класса \texttt{StorageState} реализует эту проверку.
  \item Во время обработки события «производство» произведённый тамбур помещается в будущий склад $\overline{\overline{T}}$ и переходит в текущий склад $\overline{T}$ только после завершения операции.  Аналогично, при раскрое мастер‑рулон удаляется из складов, а полученные рулоны записываются обратно после завершения операции.
  \item Если ни один станок не может начать новую операцию из‑за ограничений склада или занятости машин, алгоритм переходит к режиму ожидания: извлекается ближайшее событие из очереди $\mathcal{E}$, время $t$ сдвигается вперёд до окончания этого события, и затем обновляется состояние складов.  Это гарантирует, что следующий раскрой или производство будет возможен.
  \item Полученная история $\mathcal{H}$ представляет собой итоговую упорядоченную очередь событий $\overline{\overline{Z}}$.  События в $\mathcal{H}$ расположены по возрастанию времени окончания и полностью определяют расписание выполнения планов $\overline{\overline{X}}$ и $\overline{\overline{Y}}$.
\end{itemize}

Представленный алгоритм обеспечивает корректное согласование планов производства и раскроя с учётом складских ограничений и временной доступности машин.  Благодаря использованию очереди событий он моделирует динамическое развитие производства во времени и позволяет построить расписание, минимизирующее простои оборудования.


%------------------------------------------------------------------------------
\subsection{Случайное формирование глобального плана и начальной популяции\protect\footnote{Функция \texttt{random\_global\_plan} формирует начальный план для генетического поиска, строя случайные планы раскроя и производства.}}

Для инициализации поисковой процедуры требуется построить \emph{случайный} глобальный план $G=(\overline{\overline{X}},\overline{\overline{Y}},\overline{\overline{Z}})$, где $\overline{\overline{X}}$ и $\overline{\overline{Y}}$ --- списки локальных планов производства и раскроя.  Этот план служит одной из особей начальной популяции.  Случайное формирование осуществляется на основе распределения заказов $\mathcal{O}$ по продольно‑резательным станкам $C$ и последующего назначению необходимых мастер‑рулонов на бумагоделательные машины $M$.

\paragraph{Шаг 1: инициализация планов раскроя.}  Для каждого $c\in C$ инициализируется пустой список раскройных раскладок $P_c=\langle\rangle$.  Кодовая реализация использует конструктор \texttt{CuttingPlansBuilder}, который формирует по одной пустой раскладке для каждого станка【280686658702378†L11-L16】.  Каждый план раскроя для станка $c$ представляет собой последовательность раскладок $\bigl(P_c = (L_{c,1},L_{c,2},\dots)\bigr)$, где $L_{c,k}$ --- $k$‑я раскладка, содержащая набор заказов (рулонов) и список соответствующих мастер‑рулонов.  Изначально раскладок нет.

\paragraph{Шаг 2: разделение заказов.}  Пусть $\mathcal{O}^\mathrm{small} = \{\,j\in\mathcal{O} : \text{roll\_small}(j)=1\,\}$ --- множество «малых» заказов, требующих раскроя на ПРС/БРС, и $\mathcal{O}^\mathrm{norm} = \mathcal{O}\setminus\mathcal{O}^\mathrm{small}$ --- оставшиеся заказы.  Каждый заказ $j$ характеризуется шириной $w_j$, плотностью $\rho_j$, маркой $b_j$ и количеством экземпляров $q_j$.

\paragraph{Шаг 3: случайное перемешивание.}  Для уменьшения перекоса по маркам используется функция \texttt{\_shuffle\_rolls}【886308747777991†L7-L20】: заказы разбиваются по маркам $b_j$, внутри каждой марки случайно переставляются, после чего объединяются обратно.  Такой приём сохраняет последовательность марок, но перемешивает заказы внутри каждого класса.

\paragraph{Шаг 4: распределение малых заказов.}  Для каждого $j\in\mathcal{O}^\mathrm{small}$ и для каждого экземпляра $r$ ($r=1,\dots,q_j$) выполняется вставка рулона в случайный раскройный план.  Алгоритм \texttt{AddRollRandomly}($r$) использует множество индексов $\mathcal{C}(r)=\{\,i : \mathrm{small}(c_i)=\mathrm{small}(r)\,\}$ продольно‑резательных станков, которые могут обслуживать данный рулон【886308747777991†L56-L63】.  После случайного перемешивания $\mathcal{C}(r)$ выбирается первый индекс $i\in\mathcal{C}(r)$, для которого рулон $r$ можно добавить в последнюю раскладку $L_{c_i,\ell}$ плана $P_{c_i}$ (или в новую раскладку) без нарушения ограничения по ширине:
\[
\sum_{j\in L_{c_i,\ell}} w_j + w_r + 2e \le W_{c_i},
\]
где $W_{c_i}$ --- ширина станка $c_i$, $e$ --- ширина технологического отступа.  Если дополнение невозможно, создаётся новая раскладка $L_{c_i,\ell+1}$ с единственным рулоном $r$.  Если рулон $r$ малый, то для каждой «слоя» ($\mathrm{layers}(r)$) формируется слитый мастер‑рулон ширины $W_{c_i}$ (тип \texttt{SlittedMasterRoll})【191530593907242†L35-L53】.  Если добавление рулона не удалось ни на одном станке из $\mathcal{C}(r)$, процедура завершает работу с ошибкой.

\paragraph{Шаг 5: формирование множества слитых мастер‑рулонов.}  После распределения малых заказов для каждой раскладки $L_{c,k}$ и каждого мастер‑рулона $u\in L_{c,k}.\mathrm{master\_rolls}$ проверяется, является ли $u$ слитым.  Слитые мастер‑рулоны формируют множество $\mathcal{S}$; далее они будут рассматриваться как отдельные заказы, которые необходимо произвести на БДМ.

\paragraph{Шаг 6: распределение остальных заказов.}  Объединим «обычные» заказы и слитые мастер‑рулоны: $\mathcal{O}^\ast = \mathcal{O}^\mathrm{norm}\cup \mathcal{S}$.  После случайного перемешивания $\mathcal{O}^\ast$ по маркам (аналогично шагу 3) каждый элемент $j\in\mathcal{O}^\ast$ вставляется в планы $P_c$ аналогично шагу 4.  Если $j$ --- слитый мастер‑рулон (тип \texttt{SlittedMasterRoll}), то он рассматривается как единичный заказ; иначе для заказа $j$ добавляется по одному рулону $r$ $q_j$ раз.

\paragraph{Шаг 7: назначение производства мастер‑рулонов.}  По завершении формирования раскройных планов $P_c$ строятся планы производства на бумагоделательных машинах $M$.  Для каждого мастер‑рулона $u$ из раскладок $L_{c,k}$ находится множество совместимых БДМ $\{\,m\in M : |W_m - W_u|<\varepsilon\}$, где $W_u$ — ширина мастер‑рулона.  Случайным образом выбирается одна из совместимых машин, и мастер‑рулон добавляется в очередь производства этой машины【552227679397839†L17-L35】.  В результате получается набор планов $\overline{X} = (X_{m,1},\dots)$ для каждой $m\in M$.

\paragraph{Шаг 8: генерация событий (опционально).}  Если для задачи задан временной лимит, то на основе сформированных планов $\overline{\overline{X}}$ и $\overline{\overline{Y}}$ генерируется очередь событий $\overline{\overline{Z}}$ с помощью алгоритма, описанного в разделе~\ref{alg:generate_event_queue}; в противном случае очередь может быть заполнена позже.  Полный случайный глобальный план определяется тройкой $(\overline{\overline{X}},\overline{\overline{Y}},\overline{\overline{Z}})$.

\paragraph{Алгоритм \texttt{RandomGlobalPlan}.}  Сводя вместе изложенные шаги, процесс генерации случайного глобального плана представлен ниже.
\begin{ListingEnv}[!h]
  \captiondelim{ }
  \caption{\texttt{RandomGlobalPlan}($\mathcal{O},C,M$)}
  \begin{lstlisting}
RandomGlobalPlan(O, C, M):
    # Инициализация: P_c <- [] для всех c in C
    for c in C:
        P_c = []

    # Разделение и перемешивание заказов
    O_small, O_norm = split_orders(O)
    O_small = shuffle_by_brand(O_small)

    # Распределение малых заказов
    for j in O_small:
        for r in 1..q_j:
            AddRollRandomly(P, j)

    # Формирование множества слитых мастер-рулонов
    S = collect_slitted_master_rolls(P)

    # Распределение остальных заказов
    O_star = O_norm U S
    O_star = shuffle_by_brand(O_star)
    for j in O_star:
        if isSlittedMasterRoll(j):
            AddRollRandomly(P, j)
        else:
            for r in 1..q_j:
                AddRollRandomly(P, j)

    # Назначение производства мастер-рулонов на БДМ
    X = assign_master_rolls_to_PMS_randomly(P, M)

    # Опциональная генерация очереди событий
    if time_limit_is_set():
        Z = GenerateEventQueue((X, Y, []))

    return (X, Y, Z)
  \end{lstlisting}
\end{ListingEnv}

Рассмотренный алгоритм соответствует реализации функции \texttt{random\_global\_plan} в проекте: инициализируются планы раскроя, отбираются малые заказы, заполняются раскладки для ПРС/БРС случайным образом, затем аналогично распределяются остальные заказы и полученные слитые мастер‑рулоны, после чего строятся планы производства и, при необходимости, генерируется очередь событий【886308747777991†L22-L53】.
