\chapter{Решение задачи}\label{ch:algorithm}
\section{Используемые методы решения}
% --- начало раздела об эволюционных алгоритмах ---
\subsection{Эволюционные алгоритмы как подход}\label{subsec:theor_ch/evolutionary_approach}

Эволюционные алгоритмы представляют собой класс стохастических методов оптимизации, вдохновлённых принципами естественного отбора и генетики.
Наиболее широко применяемым вариантом является генетический алгоритм (ГА), предложенный в работах Д.~Голдберга \cite{goldberg1989genetic}.
Он оперирует популяцией решений (особей), которая эволюционирует от поколения к поколению под действием операторов отбора, кроссинговера и мутации.
Такой подход доказал свою эффективность в задачах большой размерности и со сложными пространствами поиска, в том числе в задачах раскроя и упаковки \cite{haessler1991}.

\paragraph{Основные этапы генетического алгоритма.}
\begin{enumerate}
  \item \textit{Инициализация.} Стартовая популяция формируется случайно или с использованием эвристических знаний о задаче.
В контексте CSP это может быть генерация случайных планов раскроя и расписания (см.
подраздел 2.3), обеспечивающих соблюдение всех ограничений.
  \item \textit{Оценка (функция приспособленности).} Каждая особь оценивается по целевой функции.
В многокритериальных задачах используются либо скаляризованные функции (например, взвешенная сумма критериев), либо ранжирование на основе Парето‑доминирования.
В нашем случае применяются лексикографические и взвешенные схемы, описанные в разделе 1.2.
  \item \textit{Отбор.} Особенности с наилучшей приспособленностью получают больший шанс переходить в следующее поколение.
Часто используется пропорциональный отбор, турнирный отбор или отбор по рангу.
  \item \textit{Кроссинговер.} Две родительские особи комбинируются, чтобы получить потомков.
Для задач раскроя применяются специализированные операторы: например, обмен частями планов раскроя или обмен блоками заказов между ПРС.
В нашем алгоритме вместо классического кроссинговера используется парный отбор лучших особей \cite{kureichik1998,genetics_2}, что позволяет избежать формирования недопустимых решений.
  \item \textit{Мутация.} Происходят случайные изменения в структуре особи.
Для CSP это может быть перестановка заказов внутри раскроя, замена одного формата на другой или перемещение раскроя на другую машину.
В разделе 2 описаны функции \emph{Mutate} и \emph{GlobalMutate}, реализующие локальные и глобальные изменения в планах.
  \item \textit{Замещение.} Новая популяция формируется из части старых и новых особей.
Алгоритм повторяет цикл до выполнения критерия остановки (достижения заданного числа поколений или стабилизации функции приспособленности).
\end{enumerate}

\paragraph{Преимущества эволюционных методов для CSP.}
Основное достоинство ГА — параллельный поиск во множестве точек пространства решений; это позволяет эффективно обходить локальные минимумы и находить качественные решения без необходимости полного перебора.
Эволюционные алгоритмы легко адаптируются к ограничениям: оператор мутации можно настроить так, чтобы генерировать только допустимые планы, а недопустимые решения — штрафовать.
Кроме того, ГА позволяют естественным образом учитывать несколько критериев оптимизации и реализовывать гибкие стратегии их комбинирования \cite{golfeto2009genetic,lai1997developing}.
В обзоре \cite{melega2018review} подчёркивается, что ГА и другие эволюционные методы особенно эффективны при большом количестве технологических ограничений, где традиционные оптимизационные схемы становятся непрактичными.

\paragraph{Применение к задаче раскроя.}
Одним из первых примеров использования ГА для CSP является работа Хесслера и Берды \cite{haessler1991}, где генетический алгоритм показал себя лучше классических жадных эвристик.
В последующих исследованиях ГА применялись для решения многокритериальных постановок \cite{araujo2014genetic,golfeto2009genetic} и интегрированных моделей «раскрой+расписание» \cite{kureichik1998,genetics_2,evolution_1,semenkina2013}.
Практика показывает, что правильно настроенные операторы кроссинговера и мутации, учитывающие специфику раскроя, позволяют получать решения, близкие к оптимальным, при существенно меньших вычислительных затратах, чем у точных методов.
% --- конец раздела об эволюционных алгоритмах ---

% --- начало расширенного подраздела 2.1 ---
\subsection{Метод полного перебора}\label{subsec:method/full_enumeration}

Хотя основным инструментом нашего исследования являются эволюционные методы, для целей сравнения и проверки результатов реализован \emph{метод полного перебора} (brute-force).
Его идея состоит в построении всех возможных распределений заказов между продольно‑резательными станками (ПРС) и последующего выбора наилучшего плана по целевой функции.
Каждое решение $G=(\overline{\overline{X}},\overline{\overline{Y}},\overline{\overline{Z}})$ кодируется множеством планов раскроя $\overline{\overline{Y}}=(Y_1,\dots,Y_J)$, где $Y_j$ — последовательность раскроев на $j$‑м ПРС.
Полный перебор строит их последовательно, выбирая нераспределённый заказ и назначая его на один из станков.

\paragraph{Принцип работы.}
 Прежде чем привести псевдокод, уточним общий смысл рекурсивного построения.
На каждом шаге алгоритм выбирает один из ещё не полностью выполненных заказов и рассматривает варианты назначения очередного рулона этого заказа на один из станков.
Тем самым строится дерево поиска, где вершины соответствуют частично сформированным планам $G$, а рёбра — добавлению одного рулона в план раскроя конкретного ПРС.
 
 Важно, что проверка ограничений выполняется как можно раньше: если очередной рулон не удаётся корректно «вставить» в план раскроя выбранного станка, дальнейшее углубление по этой ветви бессмысленно.
Поэтому процедура \texttt{AddPlanRoll} выступает не только как операция модификации плана, но и как механизм раннего отсечения недопустимых продолжений.
 
 Отдельно подчеркнём логику выбора \texttt{best\_G}.
Рекурсия возвращает либо пустой результат (если из текущего состояния невозможно корректно завершить план), либо некоторый допустимый план.
Поскольку допустимых планов может быть несколько, алгоритм на каждом уровне сравнивает найденные кандидаты по целевой функции (лексикографически) и запоминает лучший.
Благодаря этому итоговый ответ соответствует лучшему решению среди всех перебранных ветвей.
 
 Пусть $N=\{o_1,\dots,o_Q\}$ — множество заказов, $J$ — количество ПРС.
Построим начальный пустой план $G_0$ с $J$ пустыми планами раскроя.
Далее выполняем рекурсивную процедуру \texttt{FullEnumeration}$(G)$:

\begin{ListingEnv}[!h]
    \captiondelim{ }
    \caption{Рекурсивная процедура полного перебора}\label{alg:full_enum}
    \begin{lstlisting}
FullEnumeration(G):
    # Если все заказы распределены и ограничения выполнены
    if constraints_satisfied(G) then
        return G

    best_G = empty
    g_orders = map(order -> assigned rolls count)

    for each order o in N with remaining q_o - g_orders[o] > 0 do
        for each machine j in [1, J] do
            G' = deep copy of G
            # Попытка добавить рулон в текущий раскрой j-го станка
            if AddPlanRoll(Y'_j, o) successful then
                candidate = FullEnumeration(G')
                if candidate != empty and (best_G == empty or candidate < best_G) then
                    best_G = candidate

    return best_G
    \end{lstlisting}
\end{ListingEnv}


 В процедуре \texttt{AddPlanRoll} новый рулон пытается быть добавлен либо в последний раскрой $j$‑го ПРС, либо в новый раскрой, если по ширине станка $w_j^c$ или по признаку «малый/обычный» (parameter \texttt{small}) рулон не помещается.
Если суммарная ширина существующих форматов плюс кромка $V$ не превышает ширины станка, рулон добавляется; иначе добавление отвергается.
Таким образом, на ранних этапах отсеиваются заведомо недопустимые конфигурации раскроя.
Также на каждом шаге мы пропускаем заказы, которые уже полностью удовлетворены ($g\_orders[o] \ge q_o$).
Базовый случай возникает, когда все заказы распределены и все ограничения (\S\ref{subsec:theor_ch/criteria}) выполнены; тогда процедура возвращает готовый план.

\paragraph{Оптимизации и ограничения.}
Метод полного перебора выполняет \emph{глубокое} копирование плана $G$ при каждом ответвлении и используется лексикографическое сравнение планов, основанное на целевой функции $\mu(G)$, для выбора наилучшего кандидата.
Существенным ограничением является необходимость проверки всех возможных распределений: количество комбинаций роста экспоненциально со следующим грубым верхним пределом:
\[
  T(Q,J) \le J^Q,
\]
где $Q$ — число заказов, $J$ — число ПРС.
На практике эта оценка занижена, поскольку каждый заказ может иметь несколько слоёв и создаёт различные варианты раскроя, однако она показывает лавинообразный рост пространства поиска.
Несмотря на некоторые оптимизации (раннее отсечение недопустимых раскроев, пропуск уже выполненных заказов), метод полного перебора пригоден только для задач малой размерности (например, для демонстрационных примеров и тестирования корректности), поскольку время работы растёт экспоненциально.
В литературе подчёркивается, что такой подход используется либо для получения точного эталонного решения при малом числе заказов, либо для построения нижней оценки при более сложных методах \cite{urban2015methods,vanderbeck2000integer,delorme2016bin}.

\paragraph{Сложность.}
Каждый рекурсивный вызов функции \texttt{FullEnumeration} создаёт до $J$ подзадач, где $J$ — число ПРС, и уменьшает количество нераспределённых заказов на 1.
В худшем случае глубина рекурсии равна $Q$ (суммарное число рулонов).
Таким образом, верхняя граница сложности имеет экспоненциальный характер: $O(J^Q)$ в предположении, что все заказы совместимы со всеми ПРС.
Кроме того, оценка сложности функции \texttt{AddPlanRoll} зависит от количества раскроев на каждом станке и проверок ширины, что добавляет полиномиальный множитель.
Поэтому метод полного перебора является непрактичным при большом $Q$ и используется в работе как базовый эталон для проверки эффективности генетического алгоритма.

% --- конец расширенного подраздела 2.1 ---
% --- начало расширенного подраздела 2.2 ---
\subsection{Представление решений (кодирование плана)}\label{subsec:method/encoding}

В нашем генетическом алгоритме отдельная особь представляет собой \emph{глобальный план}
\[
G \;=\; \bigl(\,\overline{\overline{X}},\,\overline{\overline{Y}},\,\overline{\overline{Z}}\bigr),
\]
где:
\begin{itemize}
  \item $\overline{\overline{X}}=\bigl(\overline{X}_1,\dots,\overline{X}_I\bigr)$ — план выпуска тамбуров на $I$ бумагоделательных машинах (БДМ);
  \item $\overline{\overline{Y}}=\bigl(\overline{Y}_1,\dots,\overline{Y}_J\bigr)$ — план раскроя на $J$ продольно‑резательных станках (ПРС);
  \item $\overline{\overline{Z}}$ — очередь событий, формирующая расписание выполнения операций.
\end{itemize}
Особенность нашей реализации заключается в том, что фиксированной «хромосомы» в классическом смысле нет; компоненты плана связаны между собой, и изменения в одной части (например, в планах раскроя) требуют согласованных изменений в других.

\paragraph{План выпуска $\boldsymbol{\overline{\overline{X}}}$.}
Для каждой БДМ $i\in[1,I]$ формируется последовательность $\overline{X}_i = \bigl(\mu_{i,1},\mu_{i,2},\dots,\mu_{i,n_i}\bigr)$ производимых тамбуров.
Каждый $\mu_{i,j}$ характеризуется тройкой $(\text{марка},\,\text{плотность},\,\text{ширина})$ и принадлежит множеству мастер‑рулонов $\mathcal{T}$.
Порядок элементов в $\overline{X}_i$ важен: согласно технологической последовательности марок, марка в следующем тамбуре не может быть меньшей (по заранее установленному порядку) марки предыдущего.
В коде такая последовательность хранится в объекте \texttt{MakingPlan}, который содержит список мастер‑рулонов и проверяет их упорядоченность по брендам.

\paragraph{План раскроя $\boldsymbol{\overline{\overline{Y}}}$.}
Для каждого ПРС $j\in[1,J]$ составляется последовательность раскроев
\[
\overline{Y}_j = \bigl(\lambda_{j,1},\lambda_{j,2},\dots,\lambda_{j,m_j}\bigr).
\]
Каждый раскрой $\lambda_{j,k}$ является набором рулонов и (возможно) мастер‑рулонов и представляется объектом \texttt{CuttingLayout} с полями \texttt{rolls} и \texttt{master\_rolls}.
Список \texttt{rolls} упорядочен: сначала идут заказанные рулоны, затем, при необходимости, слитые мастер‑рулоны (для малых заказов); этот порядок влияет на число перестановок ножей при переходе к следующему раскрою (см. ${\tau(\overline{\overline{Y}})}$).
Для каждого $j,k$ должны выполняться ограничения:
\[
V + \sum_{r\in\lambda_{j,k}.\texttt{rolls}} r.\texttt{width} \;\le\; w^c_j,\quad
|\lambda_{j,k}.\texttt{rolls}| \;\le\; \texttt{knives}_j,
\]
где $V$ — суммарная кромка, $w^c_j$ — ширина $j$‑го ПРС, \texttt{knives}${}_j$ — количество ножей на нём.
Каждому $\lambda_{j,k}$ соответствует конкретный нарезной «слой»: в коде они организованы как список объектов \texttt{CuttingLayout} внутри \texttt{CuttingPlan}, а порядок раскроев влияет на длительность и количество перестановок ножей.

\paragraph{Связь $\boldsymbol{\overline{\overline{X}}}$ и $\boldsymbol{\overline{\overline{Y}}}$.}
Планы выпуска и раскроя связаны через мастер‑рулоны: каждый «обычный» раскрой $\lambda_{j,k}$ использует ровно один тамбур соответствующей ширины; количество тамбуров, требуемое всеми раскроями на ПРС ширины $w$, равно $\sum_{k}|\lambda_{j,k}.\texttt{master\_rolls}|$.
План выпуска $\overline{X}_i$ должен обеспечивать достаточный выпуск мастер‑рулонов для всех раскроев данного формата.
В классе \texttt{GlobalPlan} этот факт проверяется в методе \texttt{is\_valid}, где суммарное количество запланированных тамбуров сравнивается с требуемым для каждой ширины.

\paragraph{Очередь событий $\boldsymbol{\overline{\overline{Z}}}$.}
Третья компонента особи — очередь событий $\overline{\overline{Z}} = (\zeta_1,\dots,\zeta_{|\overline{\overline{Z}}|})$, которая определяет календарное расписание операций.
Каждое событие $\zeta_\ell$ имеет вид $\zeta_\ell=(e,d,z,s_\ell,h_\ell)$, где $e$ — тип события (0 — производство, 1 — раскрой), $d$ — номер машины (БДМ или ПРС), $z$ — индекс элемента в соответствующем плане ($j$‑й раскрой или $i$‑й тамбур), $s_\ell$ — время начала, $h_\ell$ — время окончания.
Очередь формируется алгоритмом \texttt{GlobalPlanEventQueueBuilder}: он последовательно ищет доступные БДМ и ПРС, добавляет события с учётом ограничений складов и выполняет переналадочные паузы.
В коде события хранятся в списке \texttt{event\_queue} в классе \texttt{GlobalPlan}; после планирования очередь сортируется по моменту начала.

\paragraph{Пример представления.}
Рассмотрим пример с двумя ПРС ($J=2$) и одной БДМ ($I=1$).
Пусть имеется 6 заказов: четыре заказа шириной 100 см (по одному рулону) и два заказа шириной 150 см (по одному рулону), а ширина ПРС равна $w^c=400\,$см, число ножей — 4.
Одна возможная особь может иметь следующий вид:
\begin{itemize}
  \item План выпуска: $\overline{X}_1=(\mu_{1,1},\mu_{1,2},\mu_{1,3})$, где $\mu_{1,1}$ и $\mu_{1,2}$ — тамбуры шириной 400 см для крупных заказов (150 +150 + кромка), а $\mu_{1,3}$ — тамбур шириной 300 см для малых заказов (100 +100 +100 + кромка).
  \item План раскроя: $\overline{Y}_1=(\lambda_{1,1},\lambda_{1,2})$, $\overline{Y}_2=(\lambda_{2,1})$.
 
        Раскрой $\lambda_{1,1}$ делит первый тамбур на два рулона шириной 150 см каждый; $\lambda_{1,2}$ делит второй тамбур аналогично.
Раскрой $\lambda_{2,1}$ использует третий тамбур и состоит из трёх рулонов по 100 см.
  \item Очередь событий: три события типа 0 (производство) на БДМ: $(0,1,1,s,h)$, $(0,1,2,s',h')$, $(0,1,3,s'',h'')$, и три события типа 1 (раскрой) на ПРС: $(1,1,1,s_1,h_1)$, $(1,1,2,s_2,h_2)$, $(1,2,1,s_3,h_3)$.
Время начала $s_\ell$ и окончания $h_\ell$ определяется производственной скоростью и степенью перекрытия операций.
\end{itemize}
Такая особь кодирует полный план: какие тамбуры производятся, как они нарезаются, на каких станках и в каком порядке; отношения между $\overline{\overline{X}}$ и $\overline{\overline{Y}}$ задают количество мастер‑рулонов каждой ширины, а очередь $\overline{\overline{Z}}$ гарантирует корректное расписание.

Детальная декомпозиция решения на $\overline{\overline{X}},\overline{\overline{Y}},\overline{\overline{Z}}$ и их взаимосвязи повышает прозрачность алгоритма и обеспечивает возможность гибко управлять структурой особей в генетическом поиске.
% --- конец расширенного подраздела 2.2 ---
% --- начало расширенного подраздела 2.3 ---
\subsection{Генерация начальной популяции}\label{subsec:method/initial_population}

Качество начального поколения сильно влияет на эффективность и скорость сходимости генетического алгоритма.
В нашей реализации каждое стартовое решение (особь) представляет собой глобальный план $G$, формируемый функцией \texttt{random\_global\_plan}.
Процедура генерации учитывает ограничения задачи и позволяют получать разнообразные особи, сохраняя допустимость.

\paragraph{Случайная генерация планов.} Генерация происходит в несколько этапов.
Сначала инициализируется пустой глобальный план $G$ с пустыми планами раскроя на каждом ПРС.
Затем выбираются \emph{малые заказы} (узкие форматы) и случайным образом переставляются по маркам: функция \texttt{\_shuffle\_rolls} группирует рулоны по брендам и перемешивает их внутри каждой группы.
Каждый малый заказ добавляется в один из планов раскроя через процедуру \texttt{\_add\_roll\_randomly}: для выбранного ПРС проверяется, помещается ли рулон в текущий раскрой; если нет, создаётся новый раскрой; рулоны распределяются, пока не будет достигнута вместимость станка.
После этого собираются слитые мастер‑рулоны, необходимые для малых заказов, и они рассматриваются как обычные заказы.

На следующем шаге аналогичным образом распределяются \emph{обычные заказы}: они перемешиваются по маркам и по одному добавляются в случайные планы раскроя.
При невозможности добавить заказ в текущий раскрой (например, из‑за нехватки ширины или ограничения по ножам) для него создаётся новый раскрой, что обеспечивает соблюдение ограничений по ширине и количеству ножей.
Таким образом формируются случайные планы раскроя $\overline{\overline{Y}}$, удовлетворяющие всем условиям.

Когда все заказы распределены, для каждого ПРС подсчитывается требуемое число мастер‑рулонов, и вызывается генератор планов производства: \texttt{generate\_pm\_plans} формирует планы $\overline{\overline{X}}$ на БДМ так, чтобы количество выпущенных тамбуров по каждой ширине соответствовало потребностям раскроя.
Если в задаче задан временной горизонт, строится календарное расписание \texttt{generate\_event\_queue}, которое превращает совокупность операций в очередность событий.

\paragraph{Детерминированные заготовки и диверсификация.} Чтобы увеличить разнообразие начальной популяции и повысить качество поиска, помимо полностью случайных глобальных планов можно включить несколько «заготовок», полученных жадными эвристиками.
Например, один или два плана можно сформировать по принципу \emph{First Fit Decreasing}: отсортировать заказы по убыванию ширины и добавлять их последовательно, выбирая каждый раз первый раскрой, куда заказ помещается.
Другой вариант — предварительное распределение заказов на основе их марок и дат сдачи, чтобы сгруппировать похожие заказы на одном ПРС и уменьшить перестановки ножей.
Такие эвристические особи могут служить «якорями» для эволюции и ускорять поиск качественных решений.
Остальные особи генерируются случайно, что обеспечивает достаточную диверсификацию популяции.

\paragraph{Выбор размера популяции.} Размер начальной популяции $P$ зависит от компромисса между временем работы алгоритма и качеством решения.
Большие популяции позволяют лучше покрыть пространство решений, но требуют больше вычислительных ресурсов; малые популяции быстрее сходятся, но повышается риск застревания в локальных минимумах.
На практике разумно выбирать $P$ в диапазоне $50$–$200$ и при необходимости адаптировать его в зависимости от трудности конкретного набора данных.
В экспериментальной части (гл.~3) показано, что увеличение $P$ сверх определённого порога даёт лишь незначительный прирост качества при существенном росте времени расчёта.

В целом описанная стратегия формирования начальной популяции позволяет обеспечить как валидность решений, так и их разнообразие, что является важным фактором для успешной работы генетического алгоритма.
% --- конец расширенного подраздела 2.3 ---
% --- начало расширенного подраздела 2.4 ---
\subsection{Оператор мутации}\label{subsec:method/mutation}

В генетическом алгоритме мутация используется для внесения локальных изменений в план раскроя, которые повышают разнообразие популяции и позволяют выйти из локальных минимумов.
В разработанном алгоритме используется два уровня мутаций: \emph{локальная} мутация одного плана раскроя $\overline{Y}_j$ и \emph{глобальная} мутация, применяемая ко всем ПРС.

\paragraph{Локальная мутация \texttt{Mutate}.}
Локальная мутация осуществляется двумя операциями: перемешиванием заказов внутри каждого раскроя и перестановкой самих раскроев.
Псевдокод локальной мутации выглядит так:
\begin{ListingEnv}[!h]
    \captiondelim{ }
    \caption{Оператор \textsc{Mutate} для плана раскроя}
    \begin{lstlisting}
Mutate(P):
    P' = deep copy of P
    for k = 1 to m do
        # Перемешивание рулонов внутри каждого раскроя
        shuffle(lambda'_k.rolls)
    # Перемешивание самих раскроев
    shuffle(P'.layouts)
    return P'
    \end{lstlisting}
\end{ListingEnv}
В реализации на Python это соответствует функции \texttt{mutate} из проекта: план копируется, в каждом раскрое перемешивается список \texttt{rolls}, затем случайным образом меняется порядок объектов \texttt{layouts}.

\paragraph{Глобальная мутация \texttt{GlobalMutate}.}
Глобальная мутация последовательно применяет оператор \textsc{Mutate} ко всем планам раскроя $\overline{Y}_j$ в глобальном плане $G$.
После каждой мутации проверяется, улучшилось ли решение (уменьшился отход или, при равном отходе, уменьшилось число перестановок ножей); если да, то мутированный план принимается, иначе отклоняется.
Затем при необходимости пересчитывается очередь событий.
Псевдокод:

\begin{ListingEnv}[!h]
    \captiondelim{ }
    \caption{Оператор \textsc{GlobalMutate} для глобального плана}
    \begin{lstlisting}
GlobalMutate(G):
    G' = deep copy of G
    for j = 1 to J do
        Y_old = G'.Y_j
        Y_new = Mutate(Y_old)
        if Y_new has less waste, or same waste and fewer knife changes then
            replace G'.Y_j with Y_new
    if Z is not empty then
        recompute event schedule
    return G'
    \end{lstlisting}
\end{ListingEnv}
Эта процедура соответствует функции \texttt{global\_mutate} в коде: на каждом ПРС вычисляется мутированный план; если он лучше, то заменяет исходный, и при наличии временных ограничений заново строится очередь событий.

\paragraph{Пример мутации.}
Рассмотрим упрощённый план раскроя на одном ПРС: $\overline{Y}_1 = (\lambda_1,\lambda_2)$, где
\[
\lambda_1 = \{\,100, 150, 100\,\},\quad \lambda_2 = \{\,120,120,80\,\}.
\]
Каждый элемент — это ширина рулона в сантиметрах, упорядоченная последовательность определяет порядок ножей.
После применения оператора \textsc{Mutate} возможны следующие изменения:
\[
\lambda'_1 = \{\,150, 100, 100\,\},\quad \lambda'_2 = \{\,120,80,120\,\},\quad\overline{Y}'_1 = (\lambda'_2,\lambda'_1).
\]
В первом раскрое рулоны переставлены так, что сначала идёт 150 см, затем два по 100 см; во втором — один из рулонов 120 см переместился в конец.
Далее сами раскрои поменялись местами.
Такая перестановка не нарушает ограничений по ширине и количеству ножей, но влияет на число перестановок ножей (например, переход с $\lambda'_2$ на $\lambda'_1$ может потребовать большего числа замен).
Если новая конфигурация уменьшает отход или снижает число перестановок, она принимается; в противном случае исходный план остаётся неизменным.

Детальное описание мутационного оператора позволяют понять, как глобальный план изменяется локально и какие критерии используются для принятия или отклонения изменений.
Такое усиление раздела повышает наглядность и демонстрирует глубину понимания методики.
% --- конец расширенного подраздела 2.4 ---
% --- начало расширенного подраздела 2.5 ---
\subsection{Оператор «кроссинговера» (парный отбор)}\label{subsec:method/crossover}

В классических генетических алгоритмах под оператором кроссинговера подразумевается обмен частями хромосом между двумя родительскими особями.
Такое смешение позволяло комбинировать признаки родителей и находить новые решения, но требует, чтобы результат оставался допустимым.
В задаче раскроя это означает, что после обмена частей плана необходимо гарантировать: (1) удовлетворение всех заказов, (2) корректность плана раскроя (ограничения по ширине, ножам и складам), (3) согласованность плана выпуска и плана раскроя, и (4) корректность расписания.
Попытки реализовать классический кроссинговер (например, обмен сегментами списков раскроев между особями) приводят к нарушениям этих условий и требуют сложных ремонтных процедур.
Поэтому в разработанном алгоритме используется \emph{парный отбор}, представляющий собой упрощённый вариант кроссинговера, сохраняющий лучшие решения без их смешивания.

\paragraph{Суть метода.}
Оператор \textsc{Crossingover} принимает на вход две особи (глобальные планы) $G_1$ и $G_2$ и возвращает лучшую из них по вектору критериев $\mu(G)$:
\[
\textsc{Crossingover}(G_1, G_2) \;=\; 
\begin{cases}
G_1, & \text{если } \mu(G_1) \le \mu(G_2),\\
G_2, & \text{иначе}.
\end{cases}
\]
Такое определение реализовано в проекте: функция \texttt{crossingover} сравнивает два плана через оператор $\le$ и возвращает тот, который имеет меньший вектор $(\omega(G),\varphi(G),\tau(\overline{\overline{Y}}))$.
Таким образом, ни один из планов не изменяется; выбирается более «приспособленный» по целевой функции.
Этот подход напоминает парный турнирный отбор, но он применяется на этапе, где в классическом ГА осуществлялся бы обмен генетической информации.

\paragraph{Преимущества парного отбора.}
Выбор лучшей особи из пары вместо классического кроссинговера даёт несколько преимуществ:
\begin{itemize}
  \item \emph{Сохранение допустимости.} Поскольку мы не смешиваем части плана, всегда получаем корректное распределение заказов и не нарушаем связи между планом раскроя, планом выпуска и расписанием.
Это избавляет от необходимости сложных ремонтных процедур.
  \item \emph{Упрощение алгоритма.} Реализация парного отбора предельно проста: достаточно сравнить две особи и выбрать лучшую.
Отпадает необходимость в дополнительной проверке или корректировке полученных потомков, что ускоряет работу алгоритма.
  \item \emph{Предотвращение ухудшения решения.} Наша функция \textsc{Crossingover} гарантирует, что результат не хуже обеих исходных особей; случайного ухудшения, характерного для некоторых вариантов кроссинговера, не происходит.
\end{itemize}

\paragraph{Пример сравнения двух решений.}
Рассмотрим две особи с векторами критериев: $\mu(G_1)=(30,\;5,\;12)$ и $\mu(G_2)=(28,\;6,\;15)$, где первое число обозначает суммарный отход (м), второе — максимальное число раскроев на станок, третье — число перестановок ножей.
Поскольку $\omega(G_2)<\omega(G_1)$, оператор возвращает $G_2$ как более выгодную особь:
\[
\textsc{Crossingover}(G_1,G_2)=G_2.
\]
Если бы первые компоненты совпадали, сравнение перешло бы ко второму критерию $\varphi(G)$ и далее к $\tau(\overline{\overline{Y}})$.

\paragraph{Классический кроссовер и его сложности.}
Мы рассматривали возможность использования традиционных операторов кроссинговера (одноточечный, двуточечный) для планов раскроя, при которых случайным образом выбирается позиция и части раскроев обмениваются между родителями.
Однако такие операторы порождают несовместимые решения: некоторые заказы могут оказаться нераспределёнными, другие — дублированными; планы раскроя и выпуска теряют согласованность; расписание становится некорректным.
Для устранения этих дефектов потребовалось бы применять сложные процедуры исправления (repair), которые компенсировали бы потенциальную выгоду от кроссинговера.
Поэтому, руководствуясь принципом простоты и надежности, мы отказались от классического кроссинговера и выбрали парный отбор как более практичную и стабильную альтернативу.

Отметим, что разработка специализированных операторов кроссинговера, учитывающих структуру глобального плана и корректность решений, представляет собой перспективное направление для дальнейших исследований.
Такой оператор мог бы, например, обменивать группы раскроев между родителями с последующей корректировкой планов производства.
Тем не менее, в рамках данной работы основной акцент сделан на генетическую мутацию, а кроссинговер реализован как механизм отбора.

% --- конец расширенного подраздела 2.5 ---


\section{Алгоритм генетического поиска}
Задачи раскроя и планирования производства традицонно рассматриваются в рамках методов линейного и целочисленного программирования, что отражено в классических и обзорных работах по задаче раскроя и её модификациям~\cite{haessler1991, martina2022}.
Вместе с тем применение точных методов в расширенных практических постановках сопряжено с существенными ограничениями.

Это обусловлено наличием большого числа дискретных, логических и технологических ограничений, связанных с использованием нескольких типов оборудования, необходимостью учёта переналадок, а также дополнительных характеристик заказов.
Как показано в ряде исследований, включение таких условий в линейные модели приводит к значительному росту размерности задачи и числа бинарных переменных~\cite{sgp_ccp2021_cutting_stock_modes, mobasher2013, vanderbeck2000}.

Кроме того, рассматриваемая задача объединяет элементы раскроя, календарного планирования и распределения ресурсов во времени, что существенно затрудняет формализацию производственного расписания в рамках классических оптимизационных моделей~\cite{gao_energy_2019, keskinocak2002}.
В связи с этим в работе применяется генетический алгоритм, позволяющий учитывать сложную структуру ограничений и получать допустимые решения за приемлемое вычислительное время, что подтверждается результатами современных исследований~\cite{klimenko2024_prin, genetics_2, klimenko2025ivdon}.


Генетические и эволюционные алгоритмы являются методами поиска и оптимизации, которые могут существенно улучшить решение задачи раскроя с минимизацией перестановок ножей.
Одним из фундаментальных преимуществ этих алгоритмов является возможность гибко управлять временем выполнения, что позволяет адаптировать их под конкретные требования задачи.
При этом каждая итерация не ухудшает качество текущего решения, что делает процесс менее уязвимым к локальным минимумам \cite{genetics_2, kureichik1998}.
Эффективность применения генетических и эволюционных алгоритмов тесно связана с мощностью вычислительных ресурсов, что часто подразумевает использование высокопроизводительных вычислительных систем, таких как суперкомпьютеры и кластеры \cite{evolution_1, semenkina2013}.


В предыдущих работах предлагался алгоритм случайного поиска с элементами генетического алгоритма, называемый генетический поиск (GS) \cite{klimenko2024_prin, klimenko2025ivdon, klimenko2025fruct}.
Однако он мог работать с учетом меньшей части условий задачи.
Данный алгоритм расширен для работы с учетом ограничений по срокам заказов, плотности рулонов, марок бумаги, кромки тамбуров, складов, слоев и БРС.

Данный алгоритм итеративно формирует новые популяции
\[
S = \{ S_1, S_2, \ldots, S_C \},
\]
где:
\begin{itemize}
    \item $S_t$ — популяция на итерации $t$, состоящая из глобальных планов раскроя $G = (\overline{\overline{X}},\overline{\overline{Y}},\overline{\overline{Z}})$;
    \item $S_{t,i}$ — $i$-й глобальный план раскроя $G \in S_t$;
    \item начальная популяция $S_0$ состоит из случайных глобальных планов $G$, удовлетворяющих ограничениям на ширину и выполнение заказов.
\end{itemize}

Размер начальной популяции определяет количество итераций, а значит, влияет на точность и скорость работы алгоритма \ref{alg:genetic_search}.

Каждая итерация включает два этапа:
\begin{enumerate}
    \item \textbf{Мутация (GlobalMutate)} (алгоритм \ref{alg:mutate} и \ref{alg:global_mutate}) — создаются новые планы $G'$.
Если новый план лучше старого $\mu(G') < \mu(G)$, то старый план заменяется.
    \item \textbf{Кроссинговер (Crossingover)} (алгоритм \ref{alg:crossingover}) — для пары соседних глобальных планов $S_{t,2i-1}$ и $S_{t,2i}$ выбирается наименьший план по $\mu(G)$.
В результате размер популяции уменьшается вдвое.
\end{enumerate}

В конце работы алгоритма остаётся один глобальный план $G'$, который не хуже любого из исходных $G \in S_0$.
Чем больше размер начальной популяции, тем выше вероятность получить $G'$ с минимальными отходами и числом перестановок ножей.
% --- начало подраздела 2.6 ---
\subsection{Параметры алгоритма и их настройка}\label{subsec:method/parameters}

Эффективность генетического алгоритма существенно зависит от выбора параметров.
Основными параметрами являются размер начальной популяции $P$, критерий остановки (число поколений $G$ или другое условие), а также вероятности применения операторов мутации и селекции.
Важно подобрать эти параметры так, чтобы обеспечить баланс между качеством решений и временем вычислений.

\paragraph{Размер популяции.}
Размер начальной популяции $P$ определяет объём пространства, который исследует алгоритм в первом поколении.
Слишком маленькая популяция может привести к преждевременной сходимости и застреванию в локальном минимуме; слишком большая — резко увеличивает время работы.
В литературе по генетическим алгоритмам рекомендуются значения $P$ в диапазоне от 30 до 200 особей для задач средней размерности.
В ходе наших экспериментов были протестированы размеры $P=50$, $100$, $200$, $500$ и $1000$.
Увеличение $P$ свыше $100$ давало лишь незначительное улучшение качества решения при существенном росте времени генерации начальной популяции и объёма памяти.
Поэтому в основной серии экспериментов размер популяции был выбран равным $100$, что обеспечило приемлемый компромисс между точностью и скоростью работы алгоритма.

\paragraph{Критерий остановки и число поколений.}
В реализованном генетическом алгоритме популяция проходит несколько этапов «эволюции»: на каждом шаге выполняются мутация и парный отбор, после чего размер популяции уменьшается примерно вдвое.
Таким образом, число поколений $G$ зависит от исходного размера популяции: для $P=100$ количество поколений составляет $G\approx \lceil \log_2 P \rceil$, то есть $6$–$7$ итераций.
Это значение оказалось достаточным для достижения стабильных результатов, и дальнейшее увеличение $G$ (например, за счёт возвращения лучших особей или сохранения части старого поколения) не приводило к заметному улучшению качества решений.

\paragraph{Мутация и селекция.}
Операторы мутации (описанные в разделе 2.4) в нашей реализации применяются к каждой особи на каждом поколении, поэтому вероятность мутации составляет $1.0$.
Это позволяет обеспечить достаточное разнообразие решений.
Однако, если задачи крупнее или если в популяции наблюдается сильный дрейф к одинаковым решениям, можно применять мутацию только к части особей (например, с вероятностью $p_{\text{mut}}=0.1$–$0.3$), как часто рекомендуется в литературе по генетическим алгоритмам.

Оператор кроссинговера заменён парным отбором, поэтому вероятность его применения равна $1.0$: каждая пара особей сравнивается и в следующее поколение переходит лучшая.
При желании можно внедрить классический кроссовер для части пар (см. раздел 2.5), однако потребуется ремонт решений для сохранения корректности плана раскроя.

\paragraph{Предварительные прогоны и настройка.}
Параметры $P$ и $G$ подбирались на основе предварительных прогоны на различных тестовых наборах.
Для каждого набора мы измеряли значения целевой функции, время работы алгоритма и стабильность результатов.
Оптимальные параметры зависят от размера задачи: для малых задач ($Q \le 50$ заказов) достаточно $P=50$ и $G=5$; для средних ($50<Q\le200$) оптимальны $P\approx100$ и $G\approx6$; для больших наборов рекомендуется увеличивать $P$ до $150$–$200$ и ограничивать время работы вместо явного числа поколений.
Рекомендации по выбору параметров можно найти также в работах Голдберга и других авторов, посвящённых генетическим алгоритмам.

Таким образом, сознательный выбор параметров и их адаптация под конкретные данные позволяют повысить эффективность генетического алгоритма и добиться лучшего качества решений при разумном времени вычисления.
% --- конец подраздела 2.6 ---
% --- начало подраздела 2.7 ---
\subsection{Псевдокод и схема алгоритма}\label{subsec:method/pseudocode}

Основной алгоритм решения задачи линейного раскроя использует генетический поиск.
Чтобы лучше понять логику работы, приведём его псевдокод в компактном виде.
 
 При чтении псевдокода удобно держать в голове, что в данной реализации «эволюция» организована как последовательное улучшение каждой особи (через \texttt{global\_mutate}) и последующее уменьшение численности популяции за счёт парного отбора.
Поэтому основной цикл сочетает два эффекта: создание локальных вариаций вокруг текущих решений и постепенное «сжатие» популяции к более качественным планам.

\begin{ListingEnv}[!h]
    \captiondelim{ }
    \caption{Генетический алгоритм для задачи линейного раскроя}\label{alg:genetic_algorithm}
    \begin{lstlisting}
GeneticAlgorithm(problem, P):
    # Инициализация: сформировать начальную популяцию S={G_1,...,G_P}
    # где каждый G_i генерируется random_global_plan и проходит проверку допустимости
    S = {G_1, ..., G_P}

    while |S| > 1 do
        # Мутация
        for each G in S do
            # Применение глобальной мутации для улучшения плана
            G = global_mutate(G)

        S' = empty
        # Парный отбор (кроссинговер)
        for i = 1 to floor(|S|/2) do
            G_{2i-1}, G_{2i} = next two individuals from S
            add crossingover(G_{2i-1}, G_{2i}) to S'

        if |S| is odd then
            move last individual from S to S'

        S = S'

    return the remaining individual G* as best found solution
    \end{lstlisting}
\end{ListingEnv}

\paragraph{Описание шагов алгоритма.}
\begin{enumerate}
  \item \textit{Формирование начальной популяции.} Создаются $P$ случайных глобальных планов $G_i$ с помощью процедуры \texttt{random\_global\_plan} и отбираются только допустимые (см. раздел 2.3).
  \item \textit{Мутация.} Каждый план подвергается глобальной мутации, в рамках которой для каждого ПРС случайно переставляются рулоны в раскроях и сами раскрои (см. раздел 2.4).
Мутация применяется детерминированно к каждой особи.
  \item \textit{Кроссинговер (парный отбор).} Население упорядочивается и разбивается на пары.
Из каждой пары в новое поколение переходит лучшая особь; если количество особей нечётно, последняя переносится без изменений (см. раздел 2.5).
  \item \textit{Итерации.} Процедуры мутации и отбора повторяются, пока популяция не сократится до одной особи.
Благодаря тому, что на каждой итерации размер популяции уменьшается примерно вдвое, общий цикл выполняется $\lceil \log_2 P \rceil$ раз.
\end{enumerate}

Для наглядности данную схему можно представить в виде блок‑диаграммы, отражающей цикл «Инициализация → Мутация → Отбор → Обновление → Проверка |S|».
Рисунок можно выполнить в виде блоков с стрелками, указывающими порядок выполнения операций.

% --- конец подраздела 2.7 ---

\subsection{Описание алгоритма Mutate}
Алгоритм получает на вход один план нарезки $Y$, состоящий из наборов раскроев $Y_{i,j}$ и форматов $y_{i,j,k}$, где ${r^Y}_{i,j,k}$~--- ширина формата, а ${{g^Y}}_{i,j,k}$~--- номер заказа.

 
 Цель оператора \textbf{Mutate} состоит в том, чтобы получить «соседнее» решение, не разрушая исходную структуру плана.
Перестановки не меняют набор выполненных заказов, однако меняют порядок следования раскроев и порядок форматов внутри раскроя.
Это важно, поскольку такие изменения могут влиять на дополнительные критерии качества (например, на число перестановок ножей) и создавать более удачные конфигурации для последующего отбора.

\begin{enumerate}
  \item Копируется исходный план $Y$ в новый $newY$, чтобы не изменять исходный объект.
  \item Для каждого раскроя $newY_{i,j}$ случайным образом перемешивается порядок форматов $y_{i,j,k}$.
  \item Случайным образом перемешивается порядок самих раскроев $newY_{i,j}$.
  \item Возвращается изменённый план $newY$.
\end{enumerate}

Таким образом, $\textbf{Mutate}(Y)$ создаёт вариацию исходного плана раскроя для поиска новых комбинаций.

\begin{ListingEnv}[!h]
    \captiondelim{ }
    \caption{Мутация отдельного плана нарезки}\label{alg:mutate}
    \begin{lstlisting}
Mutate(Y):
    newY = Y
    for each newY_{i,j} in newY do
        # Перемешать форматы y_{i,j,k} внутри раскроя
        shuffle(newY_{i,j})
    # Перемешать порядок раскроев
    shuffle(newY)
    return newY
    \end{lstlisting}
\end{ListingEnv}

\subsection{Описание алгоритма GlobalMutate}
На вход подаётся глобальный план $G = (\overline{\overline{X}}, \overline{\overline{Y}}, \overline{\overline{Z}})$.
 
 В отличие от локальной мутации, здесь принципиально важно восстановить согласованность всех компонент плана.
Изменения в $\overline{\overline{Y}}$ могут повлечь другую потребность в мастер‑рулонах по форматам, а при наличии временных ограничений — привести к другому расписанию.
Поэтому алгоритм пересобирает план производства и очередь событий, прежде чем сравнивать качество нового плана с исходным по $\mu$.

\begin{enumerate}
  \item Копируется $G$ в новый план $newG$.
  \item Для каждого плана нарезки $Y \in \overline{\overline{Y}}$ вызывается $\textbf{Mutate}(Y)$.
  \item Пересоздаётся план производства $\overline{\overline{X}}$ функцией $\textbf{GenerateProductionPlan}(newG)$ в соответствии со всеми ограничениями.
  \item Пересоздаётся очередь событий $\overline{\overline{Z}}$ функцией $\textbf{GenerateEventQueue}(newG)$ в соответствии со всеми ограничениями.
  \item Если $\mu(newG) < \mu(G)$, то выбирается $newG$.
  \item В противном случае возвращается исходный $G$.
\end{enumerate}

В шагах 5-6 алгоритм $\textbf{GlobalMutate}(G)$ обеспечивает, что решение будет не хуже исходного $G$ по целевой функции  $(\mu)$.

\begin{ListingEnv}[!h]
    \captiondelim{ }
    \caption{Мутация глобального плана}\label{alg:global_mutate}
    \begin{lstlisting}
GlobalMutate(G):
    newG = G
    for each Y in newG do
        newY = Mutate(Y)
    # Пересоздание плана производства в соответствии с новым планом нарезки
    GenerateProductionPlan(newG)
    # Пересоздание очереди событий в соответствии с новыми планами
    GenerateEventQueue(newG)
    if mu(newG) < mu(G) then
        return newG
    else
        return G
    \end{lstlisting}
\end{ListingEnv}

\subsection{Описание алгоритма Crossingover}
На вход подаются два глобальных плана $G^1$ и $G^2$.
Сравниваются значения целевых функций для обоих планов $\mu(G^1)$ и $\mu(G^2)$.
Таким образом, $\textbf{Crossingover}$ оставляет более эффективное решение.

\begin{ListingEnv}[!h]
    \captiondelim{ }
    \caption{Кроссинговер двух глобальных планов}\label{alg:crossingover}
    \begin{lstlisting}
Crossingover(G1, G2):
    if mu(G1) < mu(G2) then
        return G1
    else
        return G2
    \end{lstlisting}
\end{ListingEnv}



%------------------------------------------------------------------------------
\subsection{Генерация очереди событий\protect\footnote{Класс \texttt{GlobalPlanEventQueueBuilder} реализует построение расписания на основе планов производства и раскроя.}}

В глобальном плане $G = (\overline{\overline{X}},\overline{\overline{Y}},\overline{\overline{Z}})$ необходимо построить календарь событий $\overline{\overline{Z}}$, отражающий последовательность выпуска тамбуров на БДМ и раскроя на ПРС/БРС.
 Каждый элемент очереди $\overline{Z} = (h,\overline{h},e,d,z,\overline{T},\overline{\overline{T}},\overline{t}')$ фиксирует момент начала $h$ и окончания $\overline{h}$ работы на машине $d$, тип события $e\in\{0,1\}$ (0~— производство на БДМ, 1~— раскрой на ПРС/БРС), индекс плана $z$, а также снимки состояния складов до и после события.
 В настоящем разделе приводится математическое описание алгоритма генерации расписания на базе класса \texttt{GlobalPlanEventQueueBuilder}.

\paragraph{Инициализация.} Пусть $H$ — момент запуска производства.
 Для каждого продольно‑резательного станка $c\in C$ (ПРС/БРС) с планом раскроя $\overline{Y}_c=(Y_{c,1},\dots,Y_{c,q_c})$ определим счётчик $z_c=0$ — количество уже выполненных раскроев.
 Для каждого бумагоделательного станка $m\in M$ с планом выпуска $\overline{X}_m=(X_{m,1},\dots,X_{m,p_m})$ определим счётчик $x_m=0$ — количество произведённых тамбуров.
 Введём две структуры хранения:

\begin{itemize}
  \item \emph{Текущее состояние склада} $\overline{T}$ — набор тамбуров и рулонов, доступных для последующей нарезки.
 Изначально $\overline{T}$ пуст.
  \item \emph{Будущее состояние склада} $\overline{\overline{T}}$ — набор тамбуров, которые находятся в процессе производства на БДМ и будут переданы в $\overline{T}$ после завершения соответствующих событий.
 Изначально $\overline{\overline{T}}$ пуст.
\end{itemize}

Текущее время обозначим через $t:=H$.
 Также инициализируем две вспомогательные очереди: $\mathcal{E}$ — очередь событий с приоритетом по времени окончания (min‑heap) и $\mathcal{H}$ — история завершённых событий (будущая $\overline{\overline{Z}}$).

\paragraph{Доступные станки.} На каждом шаге алгоритма определяются множества доступных машин:
\begin{align*}
  C_{\mathrm{avail}}(t) &= \Bigl\{c\in C : z_c < |\overline{Y}_c|,\ \lambda_c \le t,\ \text{$\overline{T}$ содержит все тамбуры для раскроя $Y_{c,z_c+1}$}\Bigr\},\\
  M_{\mathrm{avail}}(t) &= \Bigl\{m\in M : x_m < |\overline{X}_m|,\ \lambda'_m \le t,\ \text{$\overline{\overline{T}}$ может вместить тамбур $X_{m,x_m+1}$}\Bigr\},
\end{align*}
где $\lambda_c$ (соответственно $\lambda'_m$) — время окончания последней операции на станке $c$ (соответственно $m$);  функция «может вместить» проверяет, что склад имеет свободную ширину и вместимость для будущего тамбура.
 Если флаг $\textit{pms\_available}=\textit{False}$, то производство на БДМ запрещено, и $M_{\mathrm{avail}}(t)$ считается пустым.

\paragraph{Определение возможных событий.} Построим множество возможных типов операций в момент времени $t$:
\begin{equation*}
  E(t) = \begin{cases}
    \{0,1\}, & \text{если } M_{\mathrm{avail}}(t)\neq\varnothing \text{ и } C_{\mathrm{avail}}(t)\neq\varnothing;\\
    \{0\}, & \text{если } M_{\mathrm{avail}}(t)\neq\varnothing \text{ и } C_{\mathrm{avail}}(t)=\varnothing;\\
    \{1\}, & \text{если } M_{\mathrm{avail}}(t)=\varnothing \text{ и } C_{\mathrm{avail}}(t)\neq\varnothing;\\
    \varnothing, & \text{если } M_{\mathrm{avail}}(t)=\varnothing \text{ и } C_{\mathrm{avail}}(t)=\varnothing.
  \end{cases}
\end{equation*}
Если $E(t)\neq\varnothing$, то можно запланировать новое событие; в противном случае придётся дождаться завершения уже запущенных операций.
 
 Данное разбиение делает явным принцип дискретно‑событийного моделирования: если в текущий момент можно начать хотя бы одну допустимую операцию, то алгоритм планирует её запуск; иначе время сдвигается к ближайшему окончанию уже начатой операции.
Такой подход позволяет корректно учитывать занятость оборудования и ограничения складов без введения искусственного равномерного временного шага.

\paragraph{Обработка событий.} Алгоритм итеративно генерирует очередь событий следующим образом.

\begin{ListingEnv}[!h]
    \captiondelim{ }
    \caption{Генерация очереди событий \texttt{GenerateEventQueue}($G$)}\label{alg:generate_event_queue}
    \begin{lstlisting}
GenerateEventQueue(G):
    # Инициализация
    t = H  # текущее время
    init z_c = 0, lambda_c = H  for all c in C
    init x_m = 0, lambda'_m = H for all m in M
    T = {}; T_future = {}
    E = {}; Hhist = {}

    # Основной цикл
    while (exists c: z_c < |Y_c|) or (exists m: x_m < |X_m|) or (E != {}) do
        # Определение доступных машин и типов операций
        C_avail(t), M_avail(t) = define_by_formulas_above()
        Etypes = E(t)
        if Etypes != {} then
            # Планируем новую операцию
            e = choose(Etypes)  # приоритет или случайный выбор
            if e == 1 then  # раскрой на ПРС/БРС
                c = choose(C_avail(t))
                R = required_reels_for(Y_{c, z_c+1})
                remove R from T and T_future
                tau = v^c_c * l^Y_{c, z_c+1} + k^c_c * (sigma(c, z_c+1) - sigma(c, z_c))
                Z = (t, t + tau, 1, c, z_c, T, T_future, {})
                push Z into E with key (t + tau)
                lambda_c = t + tau
                z_c = z_c + 1
            else  # e == 0, производство на БДМ
                m = choose(M_avail(t))
                tau = v^m_m + g^m_m * (p^X_{m, x_m+1} - p^X_{m, x_m}) + b_f
                Z = (t, t + tau, 0, m, x_m, T, T_future, {})
                push Z into E
                lambda'_m = t + tau
                x_m = x_m + 1
                place X_{m, x_m} into T_future
        else
            # Ожидание ближайшего завершения
            Z = pop_min_end_time(E)
            t = \overline{h}(Z)
            append Z to Hhist
            if e(Z) == 0 then  # завершилось производство
                move corresponding tambour from T_future to T
            else  # e(Z) == 1, завершился раскрой
                add produced rolls (from R) to T and T_future

    return Hhist  # упорядоченная очередь событий
    \end{lstlisting}
\end{ListingEnv}

\paragraph{Комментарии к алгоритму.}  
\begin{itemize}
  \item Величины $\lambda_c$ и $\lambda'_m$ фиксируют момент завершения последней операции на соответствующей машине; условие $t\ge \lambda_c$ (или $t\ge \lambda'_m$) гарантирует, что станок свободен в момент $t$.
  \item Функция $\sigma(c,z)$ обозначает суммарное количество перестановок ножей для $c$‑ой ПРС к моменту $z$‑го раскроя (см. формулу \cref{eq:slitting_time} в разделе \ref{sec:theor_ch/statement}); она используется при вычислении продолжительности раскроя.
  \item Условие «$\overline{T}$ содержит все тамбуры для раскроя $Y_{c,z_c+1}$» означает, что на складе имеются мастер‑рулоны нужной марки, плотности и ширины для выполнения очередного раскроя; функция \texttt{has\_supply} из класса \texttt{StorageState} реализует эту проверку.
  \item Во время обработки события «производство» произведённый тамбур помещается в будущий склад $\overline{\overline{T}}$ и переходит в текущий склад $\overline{T}$ только после завершения операции.
 Аналогично, при раскрое мастер‑рулон удаляется из складов, а полученные рулоны записываются обратно после завершения операции.
  \item Если ни один станок не может начать новую операцию из‑за ограничений склада или занятости машин, алгоритм переходит к режиму ожидания: извлекается ближайшее событие из очереди $\mathcal{E}$, время $t$ сдвигается вперёд до окончания этого события, и затем обновляется состояние складов.
 Это гарантирует, что следующий раскрой или производство будет возможен.
  \item Полученная история $\mathcal{H}$ представляет собой итоговую упорядоченную очередь событий $\overline{\overline{Z}}$.
 События в $\mathcal{H}$ расположены по возрастанию времени окончания и полностью определяют расписание выполнения планов $\overline{\overline{X}}$ и $\overline{\overline{Y}}$.
\end{itemize}

Представленный алгоритм обеспечивает корректное согласование планов производства и раскроя с учётом складских ограничений и временной доступности машин.
 Благодаря использованию очереди событий он моделирует динамическое развитие производства во времени и позволяют построить расписание, минимизирующее простои оборудования.


%------------------------------------------------------------------------------
\subsection{Случайное формирование глобального плана и начальной популяции\protect\footnote{Функция \texttt{random\_global\_plan} формирует начальный план для генетического поиска, строя случайные планы раскроя и производства.}}

Для инициализации поисковой процедуры требуется построить \emph{случайный} глобальный план $G=(\overline{\overline{X}},\overline{\overline{Y}},\overline{\overline{Z}})$, где $\overline{\overline{X}}$ и $\overline{\overline{Y}}$ --- списки локальных планов производства и раскроя.
 Этот план служит одной из особей начальной популяции.
 Случайное формирование осуществляется на основе распределения заказов $\mathcal{O}$ по продольно‑резательным станкам $C$ и последующего назначению необходимых мастер‑рулонов на бумагоделательные машины $M$.

\paragraph{Шаг 1: инициализация планов раскроя.}  Для каждого $c\in C$ инициализируется пустой список раскройных раскладок $P_c=\langle\rangle$.
 Кодовая реализация использует конструктор \texttt{CuttingPlansBuilder}, который формирует по одной пустой раскладке для каждого станка.
 Каждый план раскроя для станка $c$ представляет собой последовательность раскладок $\bigl(P_c = (L_{c,1},L_{c,2},\dots)\bigr)$, где $L_{c,k}$ --- $k$‑я раскладка, содержащая набор заказов (рулонов) и список соответствующих мастер‑рулонов.
 Изначально раскладок нет.

\paragraph{Шаг 2: разделение заказов.}  Пусть $\mathcal{O}^\mathrm{small} = \{\,j\in\mathcal{O} : \text{roll\_small}(j)=1\,\}$ --- множество «малых» заказов, требующих раскроя на ПРС/БРС, и $\mathcal{O}^\mathrm{norm} = \mathcal{O}\setminus\mathcal{O}^\mathrm{small}$ --- оставшиеся заказы.
 Каждый заказ $j$ характеризуется шириной $w_j$, плотностью $\rho_j$, маркой $b_j$ и количеством экземпляров $q_j$.

\paragraph{Шаг 3: случайное перемешивание.}  Для уменьшения перекоса по маркам используется функция \texttt{\_shuffle\_rolls}: заказы разбиваются по маркам $b_j$, внутри каждой марки случайно переставляются, после чего объединяются обратно.
 Такой приём сохраняет последовательность марок, но перемешивает заказы внутри каждого класса.

\paragraph{Шаг 4: распределение малых заказов.}  Для каждого $j\in\mathcal{O}^\mathrm{small}$ и для каждого экземпляра $r$ ($r=1,\dots,q_j$) выполняется вставка рулона в случайный раскройный план.
 Алгоритм \texttt{AddRollRandomly}($r$) использует множество индексов $\mathcal{C}(r)=\{\,i : \mathrm{small}(c_i)=\mathrm{small}(r)\,\}$ продольно‑резательных станков, которые могут обслуживать данный рулон.
 После случайного перемешивания $\mathcal{C}(r)$ выбирается первый индекс $i\in\mathcal{C}(r)$, для которого рулон $r$ можно добавить в последнюю раскладку $L_{c_i,\ell}$ плана $P_{c_i}$ (или в новую раскладку) без нарушения ограничения по ширине:
\[
\sum_{j\in L_{c_i,\ell}} w_j + w_r + 2e \le W_{c_i},
\]
где $W_{c_i}$ --- ширина станка $c_i$, $e$ --- ширина технологического отступа.
 Если дополнение невозможно, создаётся новая раскладка $L_{c_i,\ell+1}$ с единственным рулоном $r$.
 Если рулон $r$ малый, то для каждой «слоя» ($\mathrm{layers}(r)$) формируется слитый мастер‑рулон ширины $W_{c_i}$ (тип \texttt{SlittedMasterRoll}).
 Если добавление рулона не удалось ни на одном станке из $\mathcal{C}(r)$, процедура завершает работу с ошибкой.

\paragraph{Шаг 5: формирование множества слитых мастер‑рулонов.}  После распределения малых заказов для каждой раскладки $L_{c,k}$ и каждого мастер‑рулона $u\in L_{c,k}.\mathrm{master\_rolls}$ проверяется, является ли $u$ слитым.
 Слитые мастер‑рулоны формируют множество $\mathcal{S}$; далее они будут рассматриваться как отдельные заказы, которые необходимо произвести на БДМ.

\paragraph{Шаг 6: распределение остальных заказов.}  Объединим «обычные» заказы и слитые мастер‑рулоны: $\mathcal{O}^\ast = \mathcal{O}^\mathrm{norm}\cup \mathcal{S}$.
 После случайного перемешивания $\mathcal{O}^\ast$ по маркам (аналогично шагу 3) каждый элемент $j\in\mathcal{O}^\ast$ вставляется в планы $P_c$ аналогично шагу 4.
 Если $j$ --- слитый мастер‑рулон (тип \texttt{SlittedMasterRoll}), то он рассматривается как единичный заказ; иначе для заказа $j$ добавляется по одному рулону $r$ $q_j$ раз.

\paragraph{Шаг 7: назначение производства мастер‑рулонов.}  По завершении формирования раскройных планов $P_c$ строятся планы производства на бумагоделательных машинах $M$.
 Для каждого мастер‑рулона $u$ из раскладок $L_{c,k}$ находится множество совместимых БДМ $\{\,m\in M : |W_m - W_u|<\varepsilon\}$, где $W_u$ — ширина мастер‑рулона.
 Случайным образом выбирается одна из совместимых машин, и мастер‑рулон добавляется в очередь производства этой машины.
 В результате получается набор планов $\overline{X} = (X_{m,1},\dots)$ для каждой $m\in M$.

\paragraph{Шаг 8: генерация событий (опционально).}  Если для задачи задан временной лимит, то на основе сформированных планов $\overline{\overline{X}}$ и $\overline{\overline{Y}}$ генерируется очередь событий $\overline{\overline{Z}}$ с помощью алгоритма, описанного в разделе~\ref{alg:generate_event_queue}; в противном случае очередь может быть заполнена позже.
 Полный случайный глобальный план определяется тройкой $(\overline{\overline{X}},\overline{\overline{Y}},\overline{\overline{Z}})$.

\paragraph{Алгоритм \texttt{RandomGlobalPlan}.}  Сводя вместе изложенные шаги, процесс генерации случайного глобального плана представлен ниже.
\begin{ListingEnv}[!h]
  \captiondelim{ }
  \caption{\texttt{RandomGlobalPlan}($\mathcal{O},C,M$)}
  \begin{lstlisting}
RandomGlobalPlan(O, C, M):
    # Инициализация: P_c <- [] для всех c in C
    for c in C:
        P_c = []

    # Разделение и перемешивание заказов
    O_small, O_norm = split_orders(O)
    O_small = shuffle_by_brand(O_small)

    # Распределение малых заказов
    for j in O_small:
        for r in 1..q_j:
            AddRollRandomly(P, j)

    # Формирование множества слитых мастер-рулонов
    S = collect_slitted_master_rolls(P)

    # Распределение остальных заказов
    O_star = O_norm U S
    O_star = shuffle_by_brand(O_star)
    for j in O_star:
        if isSlittedMasterRoll(j):
            AddRollRandomly(P, j)
        else:
            for r in 1..q_j:
                AddRollRandomly(P, j)

    # Назначение производства мастер-рулонов на БДМ
    X = assign_master_rolls_to_PMS_randomly(P, M)

    # Опциональная генерация очереди событий
    if time_limit_is_set():
        Z = GenerateEventQueue((X, Y, []))

    return (X, Y, Z)
  \end{lstlisting}
\end{ListingEnv}

Рассмотренный алгоритм соответствует реализации функции \texttt{random\_global\_plan} в проекте: инициализируются планы раскроя, отбираются малые заказы, заполняются раскладки для ПРС/БРС случайным образом, затем аналогично распределяются остальные заказы и полученные слитые мастер‑рулоны, после чего строятся планы производства и, при необходимости, генерируется очередь событий.
% -------------------------------------------------------------------------------------------------------------------


\subsection{Описание алгоритма GeneticSearch}
Основной алгоритм оптимизации, который итеративно улучшает популяцию глобальных планов $S_t$.

\begin{enumerate}
  \item На вход подаётся начальная популяция $S_0$ допустимых глобальных планов $G$.
Размер $|S_0|$ влияет на баланс между скоростью и качеством поиска.
  \item Пока $|S_t| > 1$:
  \begin{enumerate}
    \item Для каждого $S_{t,i}$ вызывается $\textbf{GlobalMutate}(S_{t,i})$.
    \item Для каждой пары $(S_{t,2i-1}, S_{t,2i})$ выполняется $\textbf{Crossingover}$, и лучший план переходит в $S_{t+1}$.
    \item Если $|S_t|$ нечётное, последний план $S_{t,\lceil n/2 \rceil}$ копируется в $S_{t+1}$.
    \item Увеличивается индекс итерации $t \leftarrow t+1$.
  \end{enumerate}
  \item Когда $|S_t| = 1$, итоговый план $S_{t,1}$ возвращается как решение $G'$.
\end{enumerate}


Алгоритм $\textbf{GeneticSearch}$ сочетает случайные мутации и эволюционную селекцию, постепенно улучшая глобальный план раскроя.
Так как $\textbf{Crossingover}$ передает в следующую популяцию наилучшее из решений, а $\textbf{GlobalMutate}$ не ухудшает исходный план, то $\textbf{GeneticSearch}$ гарантирует, что выдаст решение не хуже чем в начальной популяции $S_0$.
 
 Важно отметить, что уменьшение популяции вдвое на каждой итерации означает, что алгоритм фактически выполняет серию «турниров»: на каждом шаге конкурируют пары решений, уже локально улучшенные мутацией.
Тем самым отбор работает не над исходными случайными планами, а над их локально оптимизированными вариантами, что повышает вероятность сохранения действительно качественных особей.

\begin{ListingEnv}[!h]
    \captiondelim{ }
    \caption{Генетический поиск}\label{alg:genetic_search}
    \begin{lstlisting}
GeneticSearch(S0):
    t = 0
    while |S_t| > 1 do
        n = |S_t|
        for i = 1 to n do
            S_{t,i} = GlobalMutate(S_{t,i})
        for i = 1 to floor(n/2) do
            S_{t+1,i} = Crossingover(S_{t,2i-1}, S_{t,2i})
        if n mod 2 == 1 then
            S_{t+1,ceil(n/2)} = S_{t,n}
        t = t + 1
    return S_{t,1}
    \end{lstlisting}
\end{ListingEnv}

\subsection{Сложность алгоритма}

Для алгоритма \ref{alg:genetic_search} размер популяции уменьшается вдвое на каждой итерации из-за того, что $\textbf{Crossingover}$ выбирает только один из двух планов и перадет его в следующую популяцию.
Поэтому выполняется
\[
O(|S_0|\log(|S_0|))
\]
итераций, что соответствует числу «поколений» до сокращения популяции до одного элемента при парном отборе.
Каждая итерация включает обработку планов нарезки в алгоритме \ref{alg:mutate}.
Так как план нарезки состоит из заказов, то основная вычислительная нагрузка одной итерации определяется числом обрабатываемых рулонов (то есть суммарным спросом по всем заказам) и стоимостью операций перестановки/проверок внутри планов.
Итоговая алгоритмическая сложность указана в уравнении~\ref{eq:genetic_search_complexity} без учета \textbf{GenerateProductionPlan} и \textbf{GenerateEventQueue} из алгоритма \ref{alg:global_mutate}:
\begin{equation}
    O\left(|S_0| \log(|S_0|)\sum_{i=1}^{Q} q_i \right).
    \label{eq:genetic_search_complexity}
\end{equation}

%--------------------------------------------------------
\section{Результаты}
Рассмотрим пример и результаты работы программной реализации.

\subsection{Условия примера}

В примере есть две марки бумаги C0000001 и B0000002.
Их скорости установки $B=\{0:00:00, 1:00:00\}$.
Заданы заказы, представленные в таблице~\ref{tab:orders}.

\begin{table}[h]
\centering
\caption{Множество заказов $O$}
\label{tab:orders}
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline
Заказ $i$ & $w_{i}$ & $f_{i}$ & $p_{i}$ & $l_{i}$ & $h_{i}$ & $g_{i}$ \\
\hline
${1}$ & $5$  & $1$ (C0000001) & $100$ & $2$ & 12.12.2024 8:00 & $1$ \\
${2}$ & $20$ & $2$ (B0000002) & $125$ & $2$ & 12.12.2024 8:00 & $0$ \\
${3}$ & $30$ & $1$ (C0000001) & $100$ & $1$ & 12.12.2024 8:00 & $0$ \\
${4}$ & $40$ & $1$ (C0000001) & $100$ & $1$ & 12.12.2024 8:00 & $0$ \\
${5}$ & $50$ & $2$ (B0000002) & $125$ & $1$ & 12.12.2024 8:00 & $0$ \\
\hline
\end{tabular}
\end{table}

Время начала производства $H=11.12.2024\ 8:00$.
Размер кромки тамбура $V=1$.
Далее рассмотрим множество бумагоделательных машин $M = \{m_{1}, m_{2}\}$.
Заданные машины приведены в таблице~\ref{tab:machines}.

\begin{table}[h]
\centering
\caption{Множество бумагоделательных машин $M$}
\label{tab:machines}
\begin{tabular}{|c|c|c|c|c|}
\hline
Машина $i$ & ${w^m}_{i}$ & ${v^m}_{i}$ & ${g^m}_{i}$ \\
\hline
1 & $40$ & 0:06:00 & 0:01:00 \\
2 & $60$ & 0:06:00 & 0:02:00 \\
\hline
\end{tabular}
\end{table}

Параметры ПРС приведены в таблице~\ref{tab:cutters}.

\begin{table}[h]
\centering
\caption{Множество продольно-резательных станков $C$}
\label{tab:cutters}
\begin{tabular}{|c|c|c|c|c|c|c|}
\hline
Станок $i$ & ${w^c}_{i}$ & ${n^c}_{i}$ & ${v^c}_{i}$ & ${k^c}_{i}$ & ${g^c}_{i}$ \\
\hline
$1$ & $60$ & $3$ & 1:30:00 & 48:00 & 0 \\
$2$ & $40$ & $2$ & 1:12:00 & 36:00 & 0 \\
$3$ & $20$ & $3$ & 1:12:00 & 36:00 & 1 \\
\hline
\end{tabular}
\end{table}

Кроме того, заданы склады $T = \{t_{1}, t_{2}\}$, каждый склад $t_{k}$ характеризуется максимальной шириной ${r^T}_{k}$ и вместимостью ${u^T}_{k}$ (таблица~\ref{tab:storages}).

\begin{table}[h]
\centering
\caption{Множество складов $T$}
\label{tab:storages}
\begin{tabular}{|c|c|c|}
\hline
Склад $i$ & ${r^T}_{i}$ & ${u^T}_{i}$ \\
\hline
1 & 40 & 8 \\
2 & 60 & 4 \\
\hline
\end{tabular}
\end{table}

\subsection{Решение примера}

Общий план производства бумаги представлен в таблице~\ref{tab:production_plan}.


\begin{table}[htbp]
\centering
\caption{План производства бумаги $\overline{\overline{X}}$}
\label{tab:production_plan}
\begin{tabular}{|c|ccc|ccc|}
\hline
Шаг производства $i$
  & \multicolumn{3}{c|}{$\overline{\overline{X_{1}}}$ (БДМ $m_{1}$)} 
  & \multicolumn{3}{c|}{$\overline{\overline{X_{2}}}$ (БДМ $m_{2}$)} \\
\cline{2-7}
  & ${w^X}_{1,i}$ & ${f^X}_{1,i}$ & ${p^X}_{1,i}$ 
  & ${w^X}_{2,i}$ & ${f^X}_{2,i}$ & ${p^X}_{2,i}$ \\
\hline
1 & 40 & 1 & 100 & 60 & 1 & 100 \\
2 & 40 & 1 & 100 & 60 & 1 & 100 \\
3 & 40 & 2 & 125 & 60 & 2 & 125 \\
4 & 40 & 2 & 125 & 60 & 2 & 125 \\
5 &  &  &  & 60 & 2 & 125 \\
\hline
\end{tabular}
\end{table}

Общий план нарезки бумаги представлен в таблице~\ref{tab:cutting_plan_all}.
Из-за кромки тамбура $V=1$ нельзя заполнить полностью ширину ПРС в раскрое $y_{i, j, k}$.
${g^Y}_{i,j,k}=0$ обозначает, что рулон идет на БРС $c_3$.

\begin{table}[htbp]
\centering
\caption{План нарезки бумаги $\overline{\overline{Y}}$ по ПРС $c_{i}$}
\label{tab:cutting_plan_all}
\begin{tabular}{|c|c|c|c|c|c|}
\hline
$i$ & $j$ & Форматы $y_{i,j,k}=({r^Y}_{i,j,k},{g^Y}_{i,j,k})$ & ${f^Y}_{i,j}$ & ${p^Y}_{i,j}$ & ${l^Y}_{i,j}$ \\
\hline
1 & 1 & $(40,4)$ & 1 & 100 & 1 \\
1 & 2 & $(40,4),\ (20,0)$ & 1 & 100 & 1 \\
1 & 3 & $(50,5)$ & 2 & 125 & 1 \\
1 & 4 & $(20,2),\ (20,2)$ & 2 & 125 & 2 \\
\hline
2 & 1 & $(30,3)$ & 1 & 100 & 1 \\
2 & 2 & $(20,0)$ & 1 & 100 & 1 \\
2 & 3 & $(20,2)$ & 2 & 125 & 2 \\
\hline
3 & 1 & $(5,1),\ (5,1)$ & 1 & 100 & 2 \\
\hline
\end{tabular}
\end{table}

Очередь событий представлена в таблице~\ref{tab:event_queue}.
Она описывает пошаговое выполнение плана выпуска тамбуров и их последующую нарезку на ПРС.

\begin{table}[htbp]
\centering
\renewcommand{\arraystretch}{1.1}
\setlength{\tabcolsep}{3pt}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
\hline
№ & $h$ & $\overline{h}$ & $e$ & $d$ & $z$ & $\overline{t}_1$ & $\overline{t}_2$ & $\overline{t'}$ \\
\hline
1 & 08:00 & 08:06 & 0 & 1 & 1 & $\varnothing$ & $\varnothing$ & $\varnothing$ \\
2 & 08:00 & 08:06 & 0 & 2 & 1 & $\varnothing$ & $\varnothing$ & $\varnothing$ \\
3 & 08:06 & 08:12 & 0 & 2 & 2 & $X_{1,1}$ & $X_{2,1}$ & $\varnothing$ \\
4 & 08:06 & 08:12 & 0 & 1 & 2 & $X_{1,1}$ & $X_{2,1}$ & $\varnothing$ \\
5 & 08:06 & 09:54 & 1 & 2 & 1 & $\varnothing$ & $X_{2,1}$ & $X_{1,1}$ \\
6 & 08:06 & 10:24 & 1 & 1 & 1 & $\varnothing$ & $\varnothing$ & $X_{2,1}$ \\
7 & 08:12 & 09:43 & 0 & 1 & 3 & $X_{1,2}$ & $X_{2,2}$ & $\varnothing$ \\
8 & 08:12 & 10:08 & 0 & 2 & 3 & $X_{1,2}$ & $X_{2,2}$ & $\varnothing$ \\
9 & 09:43 & 09:49 & 0 & 1 & 4 & $\{X_{1,2}, X_{1, 3}\}$ & $X_{2,2}$ & $\varnothing$ \\
10 & 09:54 & 11:42 & 1 & 2 & 2 & $\{X_{1,3}, X_{1,4}\}$ & $X_{2,2}$ & $X_{1,2}$ \\
11 & 10:08 & 10:14 & 0 & 2 & 4 & $\{X_{1,3}, X_{1,4}\}$ & $\{X_{2,2},X_{2,3}\}$ & $\varnothing$ \\
12 & 10:14 & 10:20 & 0 & 2 & 5 & $\{X_{1,3}, X_{1,4}\}$ & $\{X_{2,2},X_{2,3},X_{2,4}\}$ & $\varnothing$ \\
13 & 10:24 & 12:42 & 1 & 1 & 2 & $\{X_{1,3}, X_{1,4}\}$ & $\{X_{2,3},X_{2,4}\}$ &  $X_{2,2}$ \\
14 & 11:42 & 14:42 & 1 & 2 & 3 & $y_{2,2,1}$ & $\{X_{2,3},X_{2,4},X_{2,5}\}$ & $\{X_{1,3},X_{1,4}\}$ \\
15 & 12:42 & 16:18 & 1 & 3 & 1 & $\varnothing$ & $\{X_{2,3},X_{2,4},X_{2,5}\}$ & $\{y_{1,2,2},y_{2,2,1}\}$ \\
16 & 12:42 & 15:00 & 1 & 1 & 3 & $\varnothing$ & $\{X_{2,4},X_{2,5}\}$ & $X_{2,3}$ \\
17 & 15:00 & 19:36 & 1 & 1 & 4 & $\varnothing$ & $\varnothing$ & $\{X_{2,4},X_{2,5}\}$ \\
\hline
\end{tabular}
\caption{Очередь событий $\overline{\overline{Z}}$}
\label{tab:event_queue}
\end{table}


По результатам моделирования были получены следующие значения целевой функции:
\[
\mu(G) = \langle \omega(G),\varphi(G),\tau(\overline{\overline{Y}}) \rangle = \langle 104,\ 4,\ 10 \rangle,
\]
где $\omega(G)=104$ -- суммарная ширина отходов, $\varphi(G)=4$ -- максимальное количество раскроев на ПРС, $\tau(\overline{\overline{Y}})=10$ -- количество перестановок ножей.

Время работы программы составило 0,2 секунды для популяции размером 10.

\subsection{Сравнение популяций}

Для оценки влияния размера популяции на результаты алгоритма были проведены серии запусков с популяциями 5, $10$, 20, $100$, $1000$ и $10000$.
 
В качестве метрик использовались:  
- $\omega(G)$ — суммарная ширина отходов;  
- $\varphi(G)$ — максимальное количество раскроев на одном ПРС;  
- $\tau(\overline{\overline{Y}})$ — количество перестановок ножей;  
- Время работы программы (секунды), включая время на генерацию популяций.
 

Результаты представлены в таблице~\ref{tab:populations}.

\begin{table}[h]
\centering
\caption{Сравнение результатов при разных размерах популяции}
\label{tab:populations}
\begin{tabular}{|c|c|c|c|c|}
\hline
Размер популяции & $\omega(G)$ & $\varphi(G)$ & $\tau(\overline{\overline{Y}})$ & Время работы, сек \\
\hline
$5$    & $124$ & $5$ & $10$ & $0.04$ \\
$10$    & $104$ & $4$ & $10$ & $0.2$ \\
$20$    & $104$ & $4$ & $8$ & $0.2$ \\
$100$   & $65$  & $4$ & $9$  & $0.7$ \\
$1000$  & $65$  & $4$ & $9$  & $20.4$ \\
$10000$ & $65$  & $4$ & $9$  & $81.8$ \\
\hline
\end{tabular}
\end{table}


График на рисунке~\ref{fig:populations} иллюстрирует зависимость между размером популяции, качеством решений и временем работы.


\begin{figure}[h!]
% --- 1. Отходы
\begin{tikzpicture}
\begin{axis}[
    width=0.45\textwidth,
    height=0.35\textwidth,
    xlabel={Размер популяции},
    ylabel={$\omega(G)$},
    xmin=0, xmax=10000,
    ymin=0, ymax=150,
    xmode=log,
    log basis x=10,
    grid=both,
    xtick={10,100,1000,10000},
    xticklabels={10,100,1000,10000}
]
\addplot[
    mark=*,
    orange,
    thick
] coordinates {
    (5, 124) (10,104) (20, 104) (100,65) (1000,65) (10000,65)
};
\end{axis}
\end{tikzpicture}
\hfill
% --- 2. Раскрои
\begin{tikzpicture}
\begin{axis}[
    width=0.45\textwidth,
    height=0.35\textwidth,
    xlabel={Размер популяции},
    ylabel={$\varphi(G)$},
    xmin=0, xmax=10000,
    ymin=0, ymax=7,
    xmode=log,
    log basis x=10,
    grid=both,
    xtick={10,100,1000,10000},
    xticklabels={10,100,1000,10000}
]
\addplot[
    mark=square*,
    blue,
    thick
] coordinates {
    (5, 5) (10,4) (20, 4) (100,4) (1000,4) (10000,4)
};
\end{axis}
\end{tikzpicture}

\vspace{0.5cm}

% --- 3. Перестановки
\begin{tikzpicture}
\begin{axis}[
    width=0.45\textwidth,
    height=0.35\textwidth,
    xlabel={Размер популяции},
    ylabel={$\tau(\overline{\overline{Y}})$},
    xmin=0, xmax=10000,
    ymin=0, ymax=11,
    xmode=log,
    log basis x=10,
    grid=both,
    xtick={10,100,1000,10000},
    xticklabels={10,100,1000,10000}
]
\addplot[
    mark=triangle*,
    green!60!black,
    thick
] coordinates {
    (5, 10) (10,10) (20, 8) (100,9) (1000,9) (10000,9)
};
\end{axis}
\end{tikzpicture}
\hfill
% --- 4. Время
\begin{tikzpicture}
\begin{axis}[
    width=0.45\textwidth,
    height=0.35\textwidth,
    xlabel={Размер популяции},
    ylabel={$t$, сек},
    xmin=0, xmax=10000,
    ymin=0, ymax=100,
    xmode=log,
    log basis x=10,
    grid=both,
    xtick={10,100,1000,10000},
    xticklabels={10,100,1000,10000}
]
\addplot[
    mark=o,
    red,
    thick
] coordinates {
    (5, 0.04) (10,0.2) (20, 0.2) (100,0.7) (1000,20.4) (10000,81.8)
};
\end{axis}
\end{tikzpicture}

\caption{Сравнение популяций по метрикам: (a) отходы $\omega(G)$, (b) раскрои $\varphi(G)$, (c) перестановки ножей $\tau(\overline{\overline{Y}})$, (d) время работы программы}
\label{fig:populations}
\end{figure}
\newpage

Из таблицы~\ref{tab:populations} и рисунка~\ref{fig:populations} видно, что увеличение размера популяции приводит к снижению отходов, количества раскроев и количества перестановок ножей, однако сопровождается  ростом времени вычислений.

