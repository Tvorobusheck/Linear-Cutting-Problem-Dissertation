\chapter{Решение задачи}\label{ch:algorithm}
\section{Алгоритм}
Задачи раскроя и планирования производства традиционно рассматриваются в рамках методов линейного и целочисленного программирования, что отражено в классических и обзорных работах по задаче раскроя и её модификациям~\cite{haessler1991, martina2022}. Вместе с тем применение точных методов в расширенных практических постановках сопряжено с существенными ограничениями.

Это обусловлено наличием большого числа дискретных, логических и технологических ограничений, связанных с использованием нескольких типов оборудования, необходимостью учёта переналадок, а также дополнительных характеристик заказов. Как показано в ряде исследований, включение таких условий в линейные модели приводит к значительному росту размерности задачи и числа бинарных переменных~\cite{sgp_ccp2021_cutting_stock_modes, mobasher2013, vanderbeck2000}.

Кроме того, рассматриваемая задача объединяет элементы раскроя, календарного планирования и распределения ресурсов во времени, что существенно затрудняет формализацию производственного расписания в рамках классических оптимизационных моделей~\cite{gao_energy_2019, keskinocak2002}. В связи с этим в работе применяется генетический алгоритм, позволяющий учитывать сложную структуру ограничений и получать допустимые решения за приемлемое вычислительное время, что подтверждается результатами современных исследований~\cite{klimenko2024_prin, genetics_2, klimenko2025ivdon}.


Генетические и эволюционные алгоритмы являются методами поиска и оптимизации, которые могут существенно улучшить решение задачи раскроя с минимизацией перестановок ножей. Одним из фундаментальных преимуществ этих алгоритмов является возможность гибко управлять временем выполнения, что позволяет адаптировать их под конкретные требования задачи. При этом каждая итерация не ухудшает качество текущего решения, что делает процесс менее уязвимым к локальным минимумам \cite{genetics_2, genetics_1}. Эффективность применения генетических и эволюционных алгоритмов тесно связана с мощностью вычислительных ресурсов, что часто подразумевает использование высокопроизводительных вычислительных систем, таких как суперкомпьютеры и кластеры \cite{evolution_1, evolution_2}.


В предыдущих работах предлагался алгоритм случайного поиска с элементами генетического алгоритма, называемый генетический поиск (GS) \cite{klimenko2024_prin, klimenko2025ivdon, klimenko2025fruct}. Однако он мог работать с учетом меньшей части условий задачи. Данный алгоритм расширен для работы с учетом ограничений по срокам заказов, плотности рулонов, марок бумаги, кромки тамбуров, складов, слоев и БРС.

Данный алгоритм итеративно формирует новые популяции
\[
S = \{ S_1, S_2, \ldots, S_C \},
\]
где:
\begin{itemize}
    \item $S_t$ — популяция на итерации $t$, состоящая из глобальных планов раскроя $G = (\overline{\overline{X}},\overline{\overline{Y}},\overline{\overline{Z}})$;
    \item $S_{t,i}$ — $i$-й глобальный план раскроя $G \in S_t$;
    \item начальная популяция $S_0$ состоит из случайных глобальных планов $G$, удовлетворяющих ограничениям на ширину и выполнение заказов.
\end{itemize}

Размер начальной популяции определяет количество итераций, а значит, влияет на точность и скорость работы алгоритма \ref{alg:genetic_search}.

Каждая итерация включает два этапа:
\begin{enumerate}
    \item \textbf{Мутация (GlobalMutate)} (алгоритм \ref{alg:mutate} и \ref{alg:global_mutate}) — создаются новые планы $G'$. Если новый план лучше старого $\mu(G') < \mu(G)$, то старый план заменяется.
    \item \textbf{Кроссинговер (Crossingover)} (алгоритм \ref{alg:crossingover}) — для пары соседних глобальных планов $S_{t,2i-1}$ и $S_{t,2i}$ выбирается наименьший план по $\mu(G)$. В результате размер популяции уменьшается вдвое.
\end{enumerate}

В конце работы алгоритма остаётся один глобальный план $G'$, который не хуже любого из исходных $G \in S_0$. Чем больше размер начальной популяции, тем выше вероятность получить $G'$ с минимальными отходами и числом перестановок ножей.

\subsection{Описание алгоритма Mutate}
Алгоритм получает на вход один план нарезки $Y$, состоящий из наборов раскроев $Y_{i,j}$ и форматов $y_{i,j,k}$, где ${r^Y}_{i,j,k}$~--- ширина формата, а ${{g^Y}}_{i,j,k}$~--- номер заказа. 

\begin{enumerate}
  \item Копируется исходный план $Y$ в новый $newY$, чтобы не изменять исходный объект.
  \item Для каждого раскроя $newY_{i,j}$ случайным образом перемешивается порядок форматов $y_{i,j,k}$.
  \item Случайным образом перемешивается порядок самих раскроев $newY_{i,j}$.
  \item Возвращается изменённый план $newY$.
\end{enumerate}

Таким образом, $\textbf{Mutate}(Y)$ создаёт вариацию исходного плана раскроя для поиска новых комбинаций.

\begin{ListingEnv}[!h]
    \captiondelim{ }
    \caption{Мутация отдельного плана нарезки}\label{alg:mutate}
    \begin{lstlisting}
Mutate(Y):
    newY = Y
    for each newY_{i,j} in newY do
        # Перемешать форматы y_{i,j,k} внутри раскроя
        shuffle(newY_{i,j})
    # Перемешать порядок раскроев
    shuffle(newY)
    return newY
    \end{lstlisting}
\end{ListingEnv}

\subsection{Описание алгоритма GlobalMutate}
На вход подаётся глобальный план $G = (\overline{\overline{X}}, \overline{\overline{Y}}, \overline{\overline{Z}})$.

\begin{enumerate}
  \item Копируется $G$ в новый план $newG$.
  \item Для каждого плана нарезки $Y \in \overline{\overline{Y}}$ вызывается $\textbf{Mutate}(Y)$.
  \item Пересоздаётся план производства $\overline{\overline{X}}$ функцией $\textbf{GenerateProductionPlan}(newG)$ в соответствии со всеми ограничениями.
  \item Пересоздаётся очередь событий $\overline{\overline{Z}}$ функцией $\textbf{GenerateEventQueue}(newG)$ в соответствии со всеми ограничениями.
  \item Если $\mu(newG) < \mu(G)$, то выбирается $newG$.
  \item В противном случае возвращается исходный $G$.
\end{enumerate}

В шагах 5-6 алгоритм $\textbf{GlobalMutate}(G)$ обеспечивает, что решение будет не хуже исходного $G$ по целевой функции  $(\mu)$.

\begin{ListingEnv}[!h]
    \captiondelim{ }
    \caption{Мутация глобального плана}\label{alg:global_mutate}
    \begin{lstlisting}
GlobalMutate(G):
    newG = G
    for each Y in newG do
        newY = Mutate(Y)
    # Пересоздание плана производства в соответствии с новым планом нарезки
    GenerateProductionPlan(newG)
    # Пересоздание очереди событий в соответствии с новыми планами
    GenerateEventQueue(newG)
    if mu(newG) < mu(G) then
        return newG
    else
        return G
    \end{lstlisting}
\end{ListingEnv}

\subsection{Описание алгоритма Crossingover}
На вход подаются два глобальных плана $G^1$ и $G^2$. Сравниваются значения целевых функций для обоих планов $\mu(G^1)$ и $\mu(G^2)$. Таким образом, $\textbf{Crossingover}$ оставляет более эффективное решение.

\begin{ListingEnv}[!h]
    \captiondelim{ }
    \caption{Кроссинговер двух глобальных планов}\label{alg:crossingover}
    \begin{lstlisting}
Crossingover(G1, G2):
    if mu(G1) < mu(G2) then
        return G1
    else
        return G2
    \end{lstlisting}
\end{ListingEnv}

\subsection{Описание алгоритма GeneticSearch}
Основной алгоритм оптимизации, который итеративно улучшает популяцию глобальных планов $S_t$.

\begin{enumerate}
  \item На вход подаётся начальная популяция $S_0$ допустимых глобальных планов $G$. Размер $|S_0|$ влияет на баланс между скоростью и качеством поиска.
  \item Пока $|S_t| > 1$:
  \begin{enumerate}
    \item Для каждого $S_{t,i}$ вызывается $\textbf{GlobalMutate}(S_{t,i})$.
    \item Для каждой пары $(S_{t,2i-1}, S_{t,2i})$ выполняется $\textbf{Crossingover}$, и лучший план переходит в $S_{t+1}$.
    \item Если $|S_t|$ нечётное, последний план $S_{t,\lceil n/2 \rceil}$ копируется в $S_{t+1}$.
    \item Увеличивается индекс итерации $t \leftarrow t+1$.
  \end{enumerate}
  \item Когда $|S_t| = 1$, итоговый план $S_{t,1}$ возвращается как решение $G'$.
\end{enumerate}

Алгоритм $\textbf{GeneticSearch}$ сочетает случайные мутации и эволюционную селекцию, постепенно улучшая глобальный план раскроя. Так как $\textbf{Crossingover}$ передает в следующую популяцию наилучшее из решений, а $\textbf{GlobalMutate}$ не ухудшает исходный план, то $\textbf{GeneticSearch}$ гарантирует, что выдаст решение не хуже чем в начальной популяции $S_0$.

\begin{ListingEnv}[!h]
    \captiondelim{ }
    \caption{Генетический поиск}\label{alg:genetic_search}
    \begin{lstlisting}
GeneticSearch(S0):
    t = 0
    while |S_t| > 1 do
        n = |S_t|
        for i = 1 to n do
            S_{t,i} = GlobalMutate(S_{t,i})
        for i = 1 to floor(n/2) do
            S_{t+1,i} = Crossingover(S_{t,2i-1}, S_{t,2i})
        if n mod 2 == 1 then
            S_{t+1,ceil(n/2)} = S_{t,n}
        t = t + 1
    return S_{t,1}
    \end{lstlisting}
\end{ListingEnv}

\subsection{Сложность алгоритма}

Для алгоритма \ref{alg:genetic_search} размер популяции уменьшается вдвое на каждой итерации из-за того, что $\textbf{Crossingover}$ выбирает только один из двух планов и перадет его в следующую популяцию. Поэтому выполняется
\[
O(|S_0|\log(|S_0|))
\]
итераций. Каждая итерация включает обработку планов нарезки в алгоритме \ref{alg:mutate}. Так как план нарезки состоит из
\[
\sum_{i=1}^{Q} q_i
\]
форматов (все заказы должны быть выполнены). Итоговая алгоритмическая сложность указана в уравнении~\ref{eq:genetic_search_complexity} без учета \textbf{GenerateProductionPlan} и \textbf{GenerateEventQueue} из алгоритма \ref{alg:global_mutate}:
\begin{equation}
    O\left(|S_0| \log(|S_0|)\sum_{i=1}^{Q} q_i \right).
    \label{eq:genetic_search_complexity}
\end{equation}

%--------------------------------------------------------
\section{Результаты}
Рассмотрим пример и результаты работы программной реализации. 
\subsection{Условия примера}

В примере есть две марки бумаги C0000001 и B0000002. Их скорости установки $B=\{0:00:00, 1:00:00\}$. Заданы заказы, представленные в таблице~\ref{tab:orders}.

\begin{table}[h]
\centering
\caption{Множество заказов $O$}
\label{tab:orders}
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline
Заказ $i$ & $w_{i}$ & $f_{i}$ & $p_{i}$ & $l_{i}$ & $h_{i}$ & $g_{i}$ \\
\hline
${1}$ & $5$  & $1$ (C0000001) & $100$ & $2$ & 12.12.2024 8:00 & $1$ \\
${2}$ & $20$ & $2$ (B0000002) & $125$ & $2$ & 12.12.2024 8:00 & $0$ \\
${3}$ & $30$ & $1$ (C0000001) & $100$ & $1$ & 12.12.2024 8:00 & $0$ \\
${4}$ & $40$ & $1$ (C0000001) & $100$ & $1$ & 12.12.2024 8:00 & $0$ \\
${5}$ & $50$ & $2$ (B0000002) & $125$ & $1$ & 12.12.2024 8:00 & $0$ \\
\hline
\end{tabular}
\end{table}

Время начала производства $H=11.12.2024\ 8:00$. Размер кромки тамбура $V=1$.
Далее рассмотрим множество бумагоделательных машин $M = \{m_{1}, m_{2}\}$. Заданные машины приведены в таблице~\ref{tab:machines}.

\begin{table}[h]
\centering
\caption{Множество бумагоделательных машин $M$}
\label{tab:machines}
\begin{tabular}{|c|c|c|c|c|}
\hline
Машина $i$ & ${w^m}_{i}$ & ${v^m}_{i}$ & ${g^m}_{i}$ \\
\hline
1 & $40$ & 0:06:00 & 0:01:00 \\
2 & $60$ & 0:06:00 & 0:02:00 \\
\hline
\end{tabular}
\end{table}

Параметры ПРС приведены в таблице~\ref{tab:cutters}.

\begin{table}[h]
\centering
\caption{Множество продольно-резательных станков $C$}
\label{tab:cutters}
\begin{tabular}{|c|c|c|c|c|c|c|}
\hline
Станок $i$ & ${w^c}_{i}$ & ${n^c}_{i}$ & ${v^c}_{i}$ & ${k^c}_{i}$ & ${g^c}_{i}$ \\
\hline
$1$ & $60$ & $3$ & 1:30:00 & 48:00 & 0 \\
$2$ & $40$ & $2$ & 1:12:00 & 36:00 & 0 \\
$3$ & $20$ & $3$ & 1:12:00 & 36:00 & 1 \\
\hline
\end{tabular}
\end{table}

Кроме того, заданы склады $T = \{t_{1}, t_{2}\}$, каждый склад $t_{k}$ характеризуется максимальной шириной ${r^T}_{k}$ и вместимостью ${u^T}_{k}$ (таблица~\ref{tab:storages}).

\begin{table}[h]
\centering
\caption{Множество складов $T$}
\label{tab:storages}
\begin{tabular}{|c|c|c|}
\hline
Склад $i$ & ${r^T}_{i}$ & ${u^T}_{i}$ \\
\hline
1 & 40 & 8 \\
2 & 60 & 4 \\
\hline
\end{tabular}
\end{table}

\subsection{Решение примера}

Общий план производства бумаги представлен в таблице~\ref{tab:production_plan}.


\begin{table}[htbp]
\centering
\caption{План производства бумаги $\overline{\overline{X}}$}
\label{tab:production_plan}
\begin{tabular}{|c|ccc|ccc|}
\hline
Шаг производства $i$
  & \multicolumn{3}{c|}{$\overline{\overline{X_{1}}}$ (БДМ $m_{1}$)} 
  & \multicolumn{3}{c|}{$\overline{\overline{X_{2}}}$ (БДМ $m_{2}$)} \\
\cline{2-7}
  & ${w^X}_{1,i}$ & ${f^X}_{1,i}$ & ${p^X}_{1,i}$ 
  & ${w^X}_{2,i}$ & ${f^X}_{2,i}$ & ${p^X}_{2,i}$ \\
\hline
1 & 40 & 1 & 100 & 60 & 1 & 100 \\
2 & 40 & 1 & 100 & 60 & 1 & 100 \\
3 & 40 & 2 & 125 & 60 & 2 & 125 \\
4 & 40 & 2 & 125 & 60 & 2 & 125 \\
5 &  &  &  & 60 & 2 & 125 \\
\hline
\end{tabular}
\end{table}

Общий план нарезки бумаги представлен в таблице~\ref{tab:cutting_plan_all}. Из-за кромки тамбура $V=1$ нельзя заполнить полностью ширину ПРС в раскрое $y_{i, j, k}$. ${g^Y}_{i,j,k}=0$ обозначает, что рулон идет на БРС $c_3$.

\begin{table}[htbp]
\centering
\caption{План нарезки бумаги $\overline{\overline{Y}}$ по ПРС $c_{i}$}
\label{tab:cutting_plan_all}
\begin{tabular}{|c|c|c|c|c|c|}
\hline
$i$ & $j$ & Форматы $y_{i,j,k}=({r^Y}_{i,j,k},{g^Y}_{i,j,k})$ & ${f^Y}_{i,j}$ & ${p^Y}_{i,j}$ & ${l^Y}_{i,j}$ \\
\hline
1 & 1 & $(40,4)$ & 1 & 100 & 1 \\
1 & 2 & $(40,4),\ (20,0)$ & 1 & 100 & 1 \\
1 & 3 & $(50,5)$ & 2 & 125 & 1 \\
1 & 4 & $(20,2),\ (20,2)$ & 2 & 125 & 2 \\
\hline
2 & 1 & $(30,3)$ & 1 & 100 & 1 \\
2 & 2 & $(20,0)$ & 1 & 100 & 1 \\
2 & 3 & $(20,2)$ & 2 & 125 & 2 \\
\hline
3 & 1 & $(5,1),\ (5,1)$ & 1 & 100 & 2 \\
\hline
\end{tabular}
\end{table}

Очередь событий представлена в таблице~\ref{tab:event_queue}. Она описывает пошаговое выполнение плана выпуска тамбуров и их последующую нарезку на ПРС.

\begin{table}[htbp]
\centering
\renewcommand{\arraystretch}{1.1}
\setlength{\tabcolsep}{3pt}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
\hline
№ & $h$ & $\overline{h}$ & $e$ & $d$ & $z$ & $\overline{t}_1$ & $\overline{t}_2$ & $\overline{t'}$ \\
\hline
1 & 08:00 & 08:06 & 0 & 1 & 1 & $\varnothing$ & $\varnothing$ & $\varnothing$ \\
2 & 08:00 & 08:06 & 0 & 2 & 1 & $\varnothing$ & $\varnothing$ & $\varnothing$ \\
3 & 08:06 & 08:12 & 0 & 2 & 2 & $X_{1,1}$ & $X_{2,1}$ & $\varnothing$ \\
4 & 08:06 & 08:12 & 0 & 1 & 2 & $X_{1,1}$ & $X_{2,1}$ & $\varnothing$ \\
5 & 08:06 & 09:54 & 1 & 2 & 1 & $\varnothing$ & $X_{2,1}$ & $X_{1,1}$ \\
6 & 08:06 & 10:24 & 1 & 1 & 1 & $\varnothing$ & $\varnothing$ & $X_{2,1}$ \\
7 & 08:12 & 09:43 & 0 & 1 & 3 & $X_{1,2}$ & $X_{2,2}$ & $\varnothing$ \\
8 & 08:12 & 10:08 & 0 & 2 & 3 & $X_{1,2}$ & $X_{2,2}$ & $\varnothing$ \\
9 & 09:43 & 09:49 & 0 & 1 & 4 & $\{X_{1,2}, X_{1, 3}\}$ & $X_{2,2}$ & $\varnothing$ \\
10 & 09:54 & 11:42 & 1 & 2 & 2 & $\{X_{1,3}, X_{1,4}\}$ & $X_{2,2}$ & $X_{1,2}$ \\
11 & 10:08 & 10:14 & 0 & 2 & 4 & $\{X_{1,3}, X_{1,4}\}$ & $\{X_{2,2},X_{2,3}\}$ & $\varnothing$ \\
12 & 10:14 & 10:20 & 0 & 2 & 5 & $\{X_{1,3}, X_{1,4}\}$ & $\{X_{2,2},X_{2,3},X_{2,4}\}$ & $\varnothing$ \\
13 & 10:24 & 12:42 & 1 & 1 & 2 & $\{X_{1,3}, X_{1,4}\}$ & $\{X_{2,3},X_{2,4}\}$ &  $X_{2,2}$ \\
14 & 11:42 & 14:42 & 1 & 2 & 3 & $y_{2,2,1}$ & $\{X_{2,3},X_{2,4},X_{2,5}\}$ & $\{X_{1,3},X_{1,4}\}$ \\
15 & 12:42 & 16:18 & 1 & 3 & 1 & $\varnothing$ & $\{X_{2,3},X_{2,4},X_{2,5}\}$ & $\{y_{1,2,2},y_{2,2,1}\}$ \\
16 & 12:42 & 15:00 & 1 & 1 & 3 & $\varnothing$ & $\{X_{2,4},X_{2,5}\}$ & $X_{2,3}$ \\
17 & 15:00 & 19:36 & 1 & 1 & 4 & $\varnothing$ & $\varnothing$ & $\{X_{2,4},X_{2,5}\}$ \\
\hline
\end{tabular}
\caption{Очередь событий $\overline{\overline{Z}}$}
\label{tab:event_queue}
\end{table}


По результатам моделирования были получены следующие значения целевой функции:
\[
\mu(G) = \langle \omega(G),\varphi(G),\tau(\overline{\overline{Y}}) \rangle = \langle 104,\ 4,\ 10 \rangle,
\]
где $\omega(G)=104$ -- суммарная ширина отходов, $\varphi(G)=4$ -- максимальное количество раскроев на ПРС, $\tau(\overline{\overline{Y}})=10$ -- количество перестановок ножей.

Время работы программы составило 0,2 секунды для популяции размером 10.

\subsection{Сравнение популяций}

Для оценки влияния размера популяции на результаты алгоритма были проведены серии запусков с популяциями 5, $10$, 20, $100$, $1000$ и $10000$.  
В качестве метрик использовались:  
- $\omega(G)$ — суммарная ширина отходов;  
- $\varphi(G)$ — максимальное количество раскроев на одном ПРС;  
- $\tau(\overline{\overline{Y}})$ — количество перестановок ножей;  
- Время работы программы (секунды), включая время на генерацию популяций.  

Результаты представлены в таблице~\ref{tab:populations}.

\begin{table}[h]
\centering
\caption{Сравнение результатов при разных размерах популяции}
\label{tab:populations}
\begin{tabular}{|c|c|c|c|c|}
\hline
Размер популяции & $\omega(G)$ & $\varphi(G)$ & $\tau(\overline{\overline{Y}})$ & Время работы, сек \\
\hline
$5$    & $124$ & $5$ & $10$ & $0.04$ \\
$10$    & $104$ & $4$ & $10$ & $0.2$ \\
$20$    & $104$ & $4$ & $8$ & $0.2$ \\
$100$   & $65$  & $4$ & $9$  & $0.7$ \\
$1000$  & $65$  & $4$ & $9$  & $20.4$ \\
$10000$ & $65$  & $4$ & $9$  & $81.8$ \\
\hline
\end{tabular}
\end{table}


График на рисунке~\ref{fig:populations} иллюстрирует зависимость между размером популяции, качеством решений и временем работы.


\begin{figure}[h!]
% --- 1. Отходы
\begin{tikzpicture}
\begin{axis}[
    width=0.45\textwidth,
    height=0.35\textwidth,
    xlabel={Размер популяции},
    ylabel={$\omega(G)$},
    xmin=0, xmax=10000,
    ymin=0, ymax=150,
    xmode=log,
    log basis x=10,
    grid=both,
    xtick={10,100,1000,10000},
    xticklabels={10,100,1000,10000}
]
\addplot[
    mark=*,
    orange,
    thick
] coordinates {
    (5, 124) (10,104) (20, 104) (100,65) (1000,65) (10000,65)
};
\end{axis}
\end{tikzpicture}
\hfill
% --- 2. Раскрои
\begin{tikzpicture}
\begin{axis}[
    width=0.45\textwidth,
    height=0.35\textwidth,
    xlabel={Размер популяции},
    ylabel={$\varphi(G)$},
    xmin=0, xmax=10000,
    ymin=0, ymax=7,
    xmode=log,
    log basis x=10,
    grid=both,
    xtick={10,100,1000,10000},
    xticklabels={10,100,1000,10000}
]
\addplot[
    mark=square*,
    blue,
    thick
] coordinates {
    (5, 5) (10,4) (20, 4) (100,4) (1000,4) (10000,4)
};
\end{axis}
\end{tikzpicture}

\vspace{0.5cm}

% --- 3. Перестановки
\begin{tikzpicture}
\begin{axis}[
    width=0.45\textwidth,
    height=0.35\textwidth,
    xlabel={Размер популяции},
    ylabel={$\tau(\overline{\overline{Y}})$},
    xmin=0, xmax=10000,
    ymin=0, ymax=11,
    xmode=log,
    log basis x=10,
    grid=both,
    xtick={10,100,1000,10000},
    xticklabels={10,100,1000,10000}
]
\addplot[
    mark=triangle*,
    green!60!black,
    thick
] coordinates {
    (5, 10) (10,10) (20, 8) (100,9) (1000,9) (10000,9)
};
\end{axis}
\end{tikzpicture}
\hfill
% --- 4. Время
\begin{tikzpicture}
\begin{axis}[
    width=0.45\textwidth,
    height=0.35\textwidth,
    xlabel={Размер популяции},
    ylabel={$t$, сек},
    xmin=0, xmax=10000,
    ymin=0, ymax=100,
    xmode=log,
    log basis x=10,
    grid=both,
    xtick={10,100,1000,10000},
    xticklabels={10,100,1000,10000}
]
\addplot[
    mark=o,
    red,
    thick
] coordinates {
    (5, 0.04) (10,0.2) (20, 0.2) (100,0.7) (1000,20.4) (10000,81.8)
};
\end{axis}
\end{tikzpicture}

\caption{Сравнение популяций по метрикам: (a) отходы $\omega(G)$, (b) раскрои $\varphi(G)$, (c) перестановки ножей $\tau(\overline{\overline{Y}})$, (d) время работы программы}
\label{fig:populations}
\end{figure}
\newpage

Из таблицы~\ref{tab:populations} и рисунка~\ref{fig:populations} видно, что увеличение размера популяции приводит к снижению отходов, количества раскроев и количества перестановок ножей, однако сопровождается  ростом времени вычислений.

